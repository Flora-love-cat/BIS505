---
title: "Lab 1 BIS 505b"
author: "Maria Ciarleglio"
date: "2/8/2021"
output: 
    html_document:
        toc: true
        highlight: default
---

<!--- Copyright (c) 2021, M. Ciarleglio --->

<!--- Set global options --->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

<!--- Load packages --->
```{r, message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(arsenal)   # For bonus Lab 1 material
```

<!--- Set WD and read data file --->
```{r, include=FALSE}
#setwd("C:\\BIS_505\\LABS\\Lab1")  # modify path to your R Lab1 folder
fhs <- read.csv("data/fhs_exam1.csv")
```


# Goal of Lab 1

In **Lab 1**, we will review **(1)** important concepts in data management, **(2)** numerical and graphical summaries for quantitative variables, and **(3)** numerical and graphical summaries for categorical variables.


# Data Preparation


## Creating Categorical Variables

The first step when conducting a data analysis often involves some form of data management. This frequently involves data cleaning and creating new variables. Using the Framingham Heart Study data, we will begin by creating several categorical variables out of existing quantitative variables in the data set. Logical comparisons allow us to check conditions and logical operators allow us to check if at least one condition out of many is true (**or**, `|`) and check if multiple conditions are true (**and**, `&`).

**1. Logical Comparisons**

  - `<` less than
  - `>` greater than
  - `<=` less than or equal to
  - `>=` greater than or equal to
  - `==` equal to 
  - `!=` not equal to
  - `!x` not `x`
  - `is.na()` is `NA`
  - `!is.na()` is not `NA`

**2. Logical Operators**

  - `|` or
  - `&` and  
  
The bracket operator `[ ]` can be used to choose elements of a vector that meet certain conditions. We use this method to identify subsets of a new variable that meet a condition and then assign those entries of that new variable a particular value.

- **`[ ]` Operator**

Creating categorical variables from existing variables often involves checking conditions using the existing variables based on the following logic:

`
newvariable[check condition using existing variable] <- value assigned to newvariable when condition is TRUE
`

For example, to create an Overweight/Obese indicator variable, we would use the existing variable `BMI`. BMI 25.0 to <30 is considered overweight and BMI 30.0 or higher is considered obese.  If `BMI` is greater than or equal to 25, then the individual is flagged as being Overweight or Obese. Read the first line of code below as: the variable `OVERWEIGHTOBESE` in `fhs` equals 1 *where* `BMI >= 25`. 

```{r}
fhs$OVERWEIGHTOBESE[fhs$BMI >= 25] <- 1  # if BMI>=25 is true, OVERWEIGHTOBESE = 1
fhs$OVERWEIGHTOBESE[fhs$BMI < 25] <- 0   # if BMI<25 is true, OVERWEIGHTOBESE = 0
```

Similar logic can be used to create categorical variables with more than two categories. For example, let's create a new 4-level categorical variable `CIGPDAYGRP` describing number of cigarettes smoked/day: 0, 1-19, 20-39, and 40+. Let's also group BMI into the following categories:</span> 

- *Underweight*: BMI less than 18.5
- *Normal*: BMI between 18.5 and <25
- *Overweight*: BMI between 25.0 and <30
- *Obese*: BMI 30 or higher 

```{r}
# Grouping cigarettes smoked/day
fhs$CIGPDAYGRP[fhs$CIGPDAY == 0] = 0
fhs$CIGPDAYGRP[fhs$CIGPDAY >= 1 & fhs$CIGPDAY < 20] = 1   # 1-19 cigarettes/day
fhs$CIGPDAYGRP[fhs$CIGPDAY >= 20 & fhs$CIGPDAY < 40] = 2  # 20-39 cigarettes/day
fhs$CIGPDAYGRP[fhs$CIGPDAY >= 40] = 3                     # 40+ cigarettes/day

# Grouping BMI
fhs$BMIGRP[fhs$BMI < 18.5] = 0
fhs$BMIGRP[fhs$BMI >= 18.5 & fhs$BMI < 25] = 1
fhs$BMIGRP[fhs$BMI >= 25 & fhs$BMI < 30] = 2
fhs$BMIGRP[fhs$BMI >= 30] = 3
table(fhs$BMIGRP, useNA = "ifany")   # `useNA = "ifany"` displays NA category
```  


- **If-Else**

The `ifelse()` function provides a nice shortcut for creating a dichotomous variable based on a condition that is either TRUE or FALSE, as in the case of the variable `OVERWEIGHTOBESE` (i.e., is  `BMI >= 25` TRUE or FALSE). The `ifelse(condition checked, value if TRUE, value if FALSE)` function checks the condition specified in the first argument and the function returns the value specified in the second argument if the condition is true.  Otherwise, if the condition is false, the function returns the value specified in the third argument.

```{r}
# Equivalent method of coding Overweight/Obese indicator
fhs$OVERWEIGHTOBESE <- ifelse(fhs$BMI >= 25, 1, 0)  # if BMI>=25 is true, OVERWEIGHTOBESE = 1
                                                    # if BMI>=25 is false, OVERWEIGHTOBESE = 0
```

Thankfully, the `ifelse` statement is smart enough to know that we do not want to assign subjects with a missing value of `BMI` an `OVERWEIGHTOBESE` value of 0.  `BMI` contains `r sum(is.na(fhs$BMI))` missing values, and the table of `OVERWEIGHTOBESE` shows us that all of these subjects also have a missing value for the `OVERWEIGHTOBESE` indicator variable.

```{r}
summary(fhs$BMI) 
table(fhs$OVERWEIGHTOBESE, useNA = "ifany")
```


## Creating Factor Variables

Below, we are using the data key that was provided for the Framingham Heart Study data set to demonstrate how to turn a categorical variable into a **factor variable**. In **R**, factor variables are categorical variables that can be either character or numeric. All of our categorical variables are coded numerically, so we need to explicitly tell **R** that these variables are categorical. Most of the existing categorical variables in the `fhs` data set are dichotomous Yes/No variables coded numerically as 1/0. 

To create a factor variable, we use the `factor()` function. We can also attach labels to the `levels` (i.e., values) of the categorical variables. In addition to creating factor versions of the original variables in `fhs`, we will also turn our newly-created categorical variables, `CIGPDAYGRP` and `OVERWEIGHTOBESE` into factor variables. Ordered factor variables (i.e., ordinal variables) are created using the `ordered=TRUE` option in the `factor()` function. Equivalently, we may use the `ordered()` function instead of the `factor()` function when creating ordinal variables. The `ordered()` function has the same arguments as the `factor()` function. We will apply the `ordered()` option to `CIGPDAYGRP` and `BMIGRP`. 

The `dplyr` package includes several functions for selecting, filtering, grouping, and arranging data.  The `mutate()` function in `dplyr` is useful when creating more than one factor variable in a data frame. Below, rather than overwrite the existing numerical versions of the categorical variables in the data frame `fhs`, we create duplicate factor version of each variable using the naming convention `variablename_factor`. Creating a factor-version is optional; you can instead over-write the existing numeric version of each variable with its factor version (e.g., over-write `SEX` coded numerically as {1, 2} with `fhs$SEX = factor(fhs$SEX, levels = c(1, 2), labels = c("Male", "Female")`.)

The `unique()` function returns the the unique values of a variable and can be used to check the different values a variable can take. Below, I'm checking that `SEX` is indeed coded numerically as 1 or 2 in the `fhs` data frame.

```{r}
unique(fhs$SEX)

# fhs contains all of the variables in the original data frame, fhs, plus the factor variables below
fhs <- dplyr::mutate(fhs,                  
                     SEX_factor = factor(SEX,
                                  levels = c(1, 2),
                                  labels = c("Male", "Female")), 
                     CURSMOKE_factor = factor(CURSMOKE,
                                       levels = c(0, 1),
                                       labels = c("No", "Yes")),
                     CVD_factor = factor(CVD,
                                  levels = c(0, 1),
                                  labels = c("No", "Yes")), 
                     DEATH_factor = factor(DEATH,
                                    levels = c(0, 1),
                                    labels = c("No", "Yes")),
                     CIGPDAYGRP_factor = factor(CIGPDAYGRP,
                                         levels = c(0, 1, 2, 3),
                                         labels = c("0", "1-19", "20-39", "40+"), 
                                         ordered = TRUE))
```

We can also create individual factor variables without using the `mutate()` function.  Just be sure to add the factor variable to the `fhs` data frame using the `$` (i.e., `fhs$OVERWEIGHTOBESE_factor` is used to add the variable `OVERWEIGHTOBESE_factor` to `fhs`):

```{r}
# Creating a factor not using the `mutate()` function
fhs$BMIGRP_factor <- factor(fhs$BMIGRP,
                            levels = 0:3, 
                            labels = c("Underweight", "Normal", "Overweight", "Obese"),
                            ordered = TRUE)

fhs$OVERWEIGHTOBESE_factor <- factor(fhs$OVERWEIGHTOBESE,
                                     levels = c(0, 1),
                                     labels = c("No", "Yes"))
```  

The `levels()` function returns the levels of a factor variable; `nlevels()` returns the number of levels. 

```{r}
levels(fhs$CIGPDAYGRP_factor)
nlevels(fhs$CIGPDAYGRP_factor)
```

The `table()` function (discussed in detail in the section on **Categorical Variables**) can be used to check that the appropriate label is assigned to a given value or level using a cross-tabulation. It also provides a summary of the number of observations in each category.

```{r}
table(fhs$CIGPDAYGRP_factor, fhs$CIGPDAYGRP)
```


## Subsetting a Data Frame (Rows)

The `filter()` function in the `dplyr` package allows us to easily subset or extract data frame rows based on certain criteria. 

<center><img src="https://www.biostats.net/resources/Lab2-1.png" width="75%"></center><br>

The `filter()` function extracts rows that meet all of the specified logical criteria.

**1. Logical Comparisons**

  - `<` less than
  - `>` greater than
  - `<=` less than or equal to
  - `>=` greater than or equal to
  - `==` equal to 
  - `!=` not equal to
  - `%in%` group membership. e.g., `x %in% c(2, 3)` means that `x` is equal to 2 or 3.
  - `is.na()` is `NA`
  - `!is.na()` is not `NA`

**2. Logical Operators**

  - `|` or. `x == 2|3` means that the `x` is equal to 2 or (`|`) 3. `x %in% c(2, 3)` is equivalent to `x == 2|3`.
  - `&` and. `sex == “female” & age > 25`

The `filter()` function uses the `%>%` (**pipe**) operator to feed what is on the left of the pipe to the operation on the right. 


- **One Criterion**: Extract rows of `fhs` where `SEX_factor == "Male"` (notice the `==` when testing for equality). This subset is saved as a new data frame called `fhsM`. *Note*: the formatted label is used to check criteria involving a factor variable. 

```{r}
fhsM <- fhs %>% filter(SEX_factor == "Male")
dim(fhsM)
table(fhs$SEX_factor, useNA = "ifany", dnn = "Sex")    # original fhs data set (dnn= applies name(s) to the table dimension(s) )
table(fhsM$SEX_factor, useNA = "ifany", dnn = "Sex")   # new subset data set fhsM
```

Extract rows where `TOTCHOL` is missing (`NA`) and save these rows as a new data frame called `fhsTOTCHOLNA`.

```{r}
fhsTOTCHOLNA <- fhs %>% filter(is.na(TOTCHOL))
summary(fhs$TOTCHOL)      # checking number of NAs 
dim(fhsTOTCHOLNA)         # number of rows should equal number of NAs
```

Extract rows where `TOTCHOL` is *not* missing.

```{r}
fhsTOTCHOLCOMPLETE <- fhs %>% filter(!is.na(TOTCHOL))
sum(!is.na(fhs$TOTCHOL))   # number of non-missing values of TOTCHOL in fhs
dim(fhsTOTCHOLCOMPLETE)    # number of rows should equal number of non-missing values of TOTCHOL in fhs
```


- **Two+ Criteria**: Multiple conditions are separated by a comma. 

Extract rows of `fhs` where `SEX_factor == "Male"` and `AGE` between 40 and 50 (notice the `&` when checking the two conditions on `AGE`).

```{r}
fhsM4050 <- fhs %>% filter(SEX_factor == "Male", AGE >= 40 & AGE <= 50)
dim(fhsM4050)
head(fhsM4050)[,c("SEX_factor", "AGE")]   # print columns "SEX_factor" and "AGE" in data frame fhsM4050
```


- **`[ ]` Operator and `subset()` function**

Although this section is focusing on `dplyr` package functions, recall that we discussed subsetting a data frame using using the `[ ]` operator and using the `subset()` function in the **R-Review** document (**Section III.5**).  Again, notice that the formatted label is used when specifying the values of `SEX_factor` that are of interest.  **Note of Caution**: When creating  a subset using the bracket operator `[ ]`, **NAs are included in the subset**. This usually does not cause problems since we use the option `na.rm = TRUE` when producing numerical summary statistics. But it can cause some problems when producing certain frequency tables. To avoid these NA rows from being included when using the bracket operator `[ ]`, one option is apply the `which()` function within the bracket operator `[ ]`.  `which()` returns the indices where the condition is TRUE; these indices are the row numbers extracted from `fhs`.

```{r}
# Subset function
fhsM <- subset(fhs, SEX_factor == "Male")
dim(fhsM)

# Bracket operator
fhsM <- fhs[which(fhs$SEX_factor == "Male"),]
table(fhsM$SEX_factor, useNA = "ifany")
dim(fhsM)
```

Subsetting on more than one condition:

```{r}
# Subset function
fhsM4050 <- subset(fhs, SEX_factor == "Male" & AGE >= 40 & AGE <= 50)
dim(fhsM4050)

# Bracket operator
fhsM4050 <- fhs[which(fhs$SEX_factor == "Male" & fhs$AGE >= 40 & fhs$AGE <= 50),]
dim(fhsM4050)
```


----

<span style="color: #2980B9;">**Exercise**: Create the data frame `fhs2plus` that contains only those with `CIGPDAYGRP_factor` equal to `"40+"`. Check that you created `fhs2plus` correctly.</span> 

----

<details><summary>Answer:</summary>

```{r}
# Option 1: filter()
fhs2plus <- fhs %>% filter(CIGPDAYGRP_factor == "40+")
table(fhs2plus$CIGPDAYGRP_factor, useNA = "ifany")

# Option 2: subset()
fhs2plus <- subset(fhs, CIGPDAYGRP_factor == "40+")
table(fhs2plus$CIGPDAYGRP_factor, useNA = "ifany")

# Option 3: Bracket operator
fhs2plus <- fhs[which(fhs$CIGPDAYGRP_factor == "40+"),]
table(fhs2plus$CIGPDAYGRP_factor, useNA = "ifany")

# Careful with the bracket operator: those with missing CIGPDAYGRP_factor included below
fhs2plusNA <- fhs[fhs$CIGPDAYGRP_factor == "40+",]   # use which() with brackets to exclude NAs from the subset
table(fhs2plusNA$CIGPDAYGRP_factor, useNA = "ifany")
```

> Above, we create the data frame `fhs2plus` which only contains observations in the 40+ cigarette category (there are `r table(fhs2plus$CIGPDAYGRP_factor, useNA = "ifany")[4]` observations in that category).

</details>  
\  
  


## Subsetting a Data Frame (Columns)

The `select()` function in the `dplyr` package allows us to select variables (i.e., columns) in a data frame.

<center><img src="https://www.biostats.net/resources/Lab2-2.png" width="75%"></center><br>

Below, we are selecting the outcome variables of interest from the `fhs` data frame and storing them in the new data frame `fhsoutcomes`:

```{r}
fhsoutcomes <- fhs %>% select(CVD_factor, DEATH_factor)
head(fhsoutcomes)
```

Equivalently, using the `[ ]` operator (i.e., not using `dplyr` package):

```{r}
# Bracket operator
fhsoutcomes2 <- fhs[,c("CVD_factor", "DEATH_factor")]
head(fhsoutcomes2)
```


# Quantitative Variables

**Quantitative variables** are summarized using summary statistics such as mean, median, standard deviation, IQR, and range. We typically present summary statistics for the overall study sample and within subgroups of interest. Graphical summaries such as histograms and boxplots allow us to see the shape of the distribution of the variable and can also be presented by subgroup. 


## Numerical Summaries


### Overall

The built-in functions below provide numerical summaries of quantitative variables. The option `na.rm = TRUE` is required in many of the functions if the variable analyzed contains missing values (NAs). The `na.rm = TRUE` option tells the function to remove NAs before performing any calculations.

Function            |  Description                      |
:-------------------|:----------------------------------|
`sum(!is.na(x))`    | Number of non-missing values |
`sum(is.na(x))`     | Number of missing values |
`mean(x)`           | Mean; `na.rm = TRUE` |
`sd(x)`             | Standard deviation; `na.rm = TRUE` |
`var(x)`            | Variance; `na.rm = TRUE` |
`min(x)`            | Minimum; `na.rm = TRUE` |
`max(x)`            | Maximum; `na.rm = TRUE` |
`median(x)`         | Median; `na.rm = TRUE` |
`range(x)`          | Range of values (minimum and maximum); `na.rm = TRUE` |
`quantile(x)`       | 0, 25, 50, 75 and 100th percentile; `quantile(x, probs = 0.25)` returns specific percentile; `type = 2` matches class method of computing $Q_1$ and $Q_3$; `na.rm = TRUE` |
`IQR(x)`            | Interquartile range ($Q_3 - Q_1$); `type =` option available, `na.rm = TRUE` |
`summary(x)`        | Minimum, $Q_1$, median, mean, $Q_3$, maximum, and number of missing values (if any); `quantile.type =` option available |  
`fivenum(x)`        | Five number summary (minimum, $Q_1$, median, $Q_3$, maximum); `na.rm = TRUE` |

```{r}
sum(!is.na(fhs$TOTCHOL))
mean(fhs$TOTCHOL)
mean(fhs$TOTCHOL, na.rm=TRUE)
sd(fhs$TOTCHOL, na.rm=TRUE)
var(fhs$TOTCHOL, na.rm=TRUE)
min(fhs$TOTCHOL, na.rm=TRUE)
max(fhs$TOTCHOL, na.rm=TRUE)
range(fhs$TOTCHOL, na.rm=TRUE)
median(fhs$TOTCHOL, na.rm=TRUE)
quantile(fhs$TOTCHOL, type=2, na.rm=TRUE)
quantile(fhs$TOTCHOL, type=2, probs=0.75, na.rm=TRUE)  # request specific percentile with probs=
IQR(fhs$TOTCHOL, na.rm=TRUE)
summary(fhs$TOTCHOL)
fivenum(fhs$TOTCHOL, na.rm=TRUE)
```

There is no built-in function to find the mode of a variable. However, we can simply find the most frequently occurring value of a variable by creating a table of its unique values using the `table()` function (discussed more in the section on **Categorical Variables**) and sorting the number of occurrences from highest to lowest using the sort()` function. 

```{r}
tab <- table(fhs$TOTCHOL)                # number of occurrences for each unique value
names(sort(tab, decreasing = TRUE)[1])   # sort highest to lowest, pick highest (i.e., first element)
```

Recall from **Lab 0** that it is possible to embed **R** code in a line of markdown text. For example:

> The average total cholesterol level at exam 1 in the `r sum(!is.na(fhs$TOTCHOL))` subjects in the Framingham Heart Study is `r round(mean(fhs$TOTCHOL, na.rm=TRUE), 2)` mg/dL with a standard deviation `r round(sd(fhs$TOTCHOL, na.rm=TRUE),2)`.  The range of cholesterol values is `r min(fhs$TOTCHOL, na.rm=TRUE)` - `r max(fhs$TOTCHOL, na.rm=TRUE)`.

Manual pipe tables can also be combined with inline **R** code to create summary tables:

Variable     |  Mean (SD)                                            |
:------------|:-----------------------------------------------------:|
Age                   | `r round(mean(fhs$AGE, na.rm=TRUE), 2)` (`r round(sd(fhs$AGE, na.rm=TRUE), 2)`) |
BMI                   | `r round(mean(fhs$BMI, na.rm=TRUE), 2)` (`r round(sd(fhs$BMI, na.rm=TRUE), 2)`) |
Cigarettes smoked/day | `r round(mean(fhs$CIGPDAY, na.rm=TRUE), 2)` (`r round(sd(fhs$CIGPDAY, na.rm=TRUE), 2)`) |
Diastolic BP          | `r round(mean(fhs$DIABP, na.rm=TRUE), 2)` (`r round(sd(fhs$DIABP, na.rm=TRUE), 2)`) |
Systolic BP           | `r round(mean(fhs$SYSBP, na.rm=TRUE), 2)` (`r round(sd(fhs$SYSBP, na.rm=TRUE), 2)`) |


### By Group

In addition to describing the overall sample, it is useful to compare data between two or more defined (categorical) groups. For example, we may be interested in comparing the characteristics above (`AGE`, `BMI`, `CIGPDAY`, etc.) in those who are overweight/obese vs. those who are not overweight/obese. 

- **Option 1:** The `by()` function allows us to separate the data frame into subgroups defined by the second variable (`OVERWEIGHTOBESE_factor`) and applies the function specified (e.g., `mean`, `sd`, `var`, `min`, `median`, `max`, `summary`) to each subgroup.

```{r}
by(fhs$AGE, fhs$OVERWEIGHTOBESE_factor, mean, na.rm=TRUE)
by(fhs$AGE, fhs$OVERWEIGHTOBESE_factor, sd, na.rm=TRUE)
by(fhs$AGE, fhs$OVERWEIGHTOBESE_factor, min, na.rm=TRUE)
by(fhs$AGE, fhs$OVERWEIGHTOBESE_factor, summary)
```


----

<span style="color: #2980B9;">**Exercise**: Produce some summary statistics for `AGE` by `SEX_factor` in those who smoke 40+ cigarettes/day. Recall that we created `fhs2plus` in the previous exercise. </span> 

----

<details><summary>Answer:</summary>

```{r}
by(fhs2plus$AGE, fhs2plus$SEX_factor, mean, na.rm=TRUE)  # mean of age by sex
by(fhs2plus$AGE, fhs2plus$SEX_factor, sd, na.rm=TRUE)    # sd of age by sex
```

> On average, males who smoke 40+ cigarettes/day are `r round(by(fhs2plus$AGE, fhs2plus$SEX_factor, mean, na.rm=TRUE)[1],2)` years old; on average, females who smoke 40+ cigarettes/day are `r round(by(fhs2plus$AGE, fhs2plus$SEX_factor, mean, na.rm=TRUE)[2],2)` years old.

</details>  
\  


- **Option 2:** We can apply summary statistic functions on subsets using the bracket operator `[ ]` or the `subset()` function. The `filter()` function in the `dplyr` package also allows us to create the data frames for each subgroup.

`[ ]` operator:
```{r}
# [ ] operator broken into two steps
grp1 = fhs[which(fhs$OVERWEIGHTOBESE_factor == "No"),]    # new data frame containing subgroup 1
mean(grp1$AGE, na.rm=TRUE)                                # compute mean using grp1 data frame
grp2 = fhs[which(fhs$OVERWEIGHTOBESE_factor == "Yes"),]   # new data frame containing subgroup 2
mean(grp2$AGE, na.rm=TRUE)                                # compute mean using grp2 data frame

# [ ] operator all in one step
mean(fhs$AGE[which(fhs$OVERWEIGHTOBESE_factor == "No")], na.rm=TRUE)
mean(fhs$AGE[which(fhs$OVERWEIGHTOBESE_factor == "Yes")], na.rm=TRUE)

# [ ] operator all in one step (use of which() is optional, here, since we drop missings with na.rm=TRUE)
mean(fhs$AGE[fhs$OVERWEIGHTOBESE_factor == "No"], na.rm=TRUE)    # same answer as above (using which())
mean(fhs$AGE[fhs$OVERWEIGHTOBESE_factor == "Yes"], na.rm=TRUE)   # same answer as above (using which())
```


`subset()` function:
```{r}
# subset function broken into two steps
grp1 = subset(fhs, OVERWEIGHTOBESE_factor == "No")   # new data frame containing subgroup 1
mean(grp1$AGE, na.rm=TRUE)                           # compute mean using grp1 data frame
grp2 = subset(fhs, OVERWEIGHTOBESE_factor == "Yes")  # new data frame containing subgroup 2
mean(grp2$AGE, na.rm=TRUE)                           # compute mean using grp2 data frame

# subset function all in one step
mean(subset(fhs, OVERWEIGHTOBESE_factor == "No")$AGE, na.rm=TRUE) 
mean(subset(fhs, OVERWEIGHTOBESE_factor == "Yes")$AGE, na.rm=TRUE)
```


## Graphical Summaries

Histograms and boxplots are the two primary graphical measures used to summarize quantitative variables. 

### Overall

**Histograms** are created using the `hist()` function. By default, **R** displays the frequency on the y-axis (i.e., the number of observations in each bin). **R** automatically chooses the bin size and the bin breaks for the histogram. You can manually specify either the number of bins or a vector of the break points between histogram bins. By default, the bins are **right-closed** (left open) intervals (i.e., (lower, upper]). Request `right = FALSE` gives **left-closed** intervals, [lower, upper). The option `las = 1` changes the orientation of the text on the y-axis so that it is perpendicular to the axis.

```{r, fig.align="center", fig.width=6, fig.cap="Total Cholesterol at Exam 1 in Framingham Heart Study"}
summary(fhs$TOTCHOL)  # helps us define the range of our axis
hist(fhs$TOTCHOL,
     breaks = seq(100, 700, by=100),
     right = FALSE,   # left-closed intervals (preferred)
     main = "",       # no figure title because we are requesting a figure caption in code chunk header
     xlab = "Total Cholesterol", 
     ylab = "Frequency",
     las = 1)         # rotate y-axis text
```
\

We can change the y-axis to display relative frequency by first saving the histogram to an object (called `h`, here).  This will not plot the histogram because we specified `plot = FALSE` in the `hist()` function. `h` contains a vector called `counts` that gives the number of observations in each bin.  We access this vector using `h$counts`. Next, we redefine `h$counts` as the relative frequency (`100 * h$counts / sum(h$counts)`) and plot the histogram by running `plot(h)`. 

```{r, fig.align="center", fig.width=6, fig.cap="Total Cholesterol at Exam 1 in Framingham Heart Study"}
h <- hist(fhs$TOTCHOL, breaks = seq(100, 700, by=50), plot = FALSE)
h$counts <- 100 * h$counts / sum(h$counts)   # relative frequency
plot(h, 
     main = "",        # no figure title 
     xlab = "Total Cholesterol", 
     ylab = "Relative Frequency (%)",
     col = "gray",     # bar colors
     las = 1)          # rotate y-axis text
```
\


**Boxplots** are created using the `boxplot()` function. By default, vertical boxplots are produced. Request a horizontal boxplot using the `horizontal = TRUE` option.

```{r, out.width=c('50%', '50%'), fig.show='hold'}
boxplot(fhs$TOTCHOL,
        ylab = "Total Cholesterol",
        las = 1)

boxplot(fhs$TOTCHOL,
        xlab = "Total Cholesterol",
        horizontal = TRUE)
```


### By Group

Creating plots for each subgroup allows us to visually compare the distributions.  When plotting the data for each subgroup, it is important that the axes have the same range so that the graphs are directly comparable. 

We begin by plotting **histograms** by group. We first create two data frames that contain non-overweight/obese participants `grp1` and overweight/obese participants `grp0`, respectively, using the `subset()` function.  In order to set the range of the x-axis, we use the `range()` function to find the minimum and maximum of the quantitative variable being plotted (`TOTCHOL`, here). We will use this information to set the range of the x-axis when specifying the upper and lower limits of the the vector of histogram bin breaks (`breaks = c()`) in the histograms for each subgroup.

```{r}
grp1 <- subset(fhs, OVERWEIGHTOBESE_factor == "No")  # new data frame containing subgroup 1
grp2 <- subset(fhs, OVERWEIGHTOBESE_factor == "Yes") # new data frame containing subgroup 2

range(grp1$TOTCHOL, grp2$TOTCHOL, na.rm=TRUE)  # Want x-axis range to be the same in both histograms
```

We see that the smallest value of `TOTCHOL` in the two subgroups is `r min(grp1$TOTCHOL, grp2$TOTCHOL, na.rm=TRUE)` and the largest value is `r max(grp1$TOTCHOL, grp2$TOTCHOL, na.rm=TRUE)`. Using this information, we will set the lower and upper limits of the histogram bin breaks in both histograms at 100 and 700, respectively.  

`par(mfrow=c(rows, cols))` allows us to put multiple plots in the same plot area. For example, to create two plots side-by-side, request a plot layout of 1 row and 2 columns using `par(mfrow=c(1,2))`. Reset the plotting area to the traditional 1x1 plot using `par(mfrow=c(1,1))`.

```{r, fig.align="center", fig.width=6}
par(mfrow = c(1,2))   # figures will be plotted in 1 row, 2 columns

hist(grp1$TOTCHOL, 
     breaks = seq(100, 700, by=50),
     main = "Not Overweight/Obese", 
     xlab = "Total Cholesterol", 
     ylab = "Frequency", 
     col = "gray", 
     las = 1)

hist(grp2$TOTCHOL, 
     breaks = seq(100, 700, by=50), 
     main = "Overweight/Obese",
     xlab = "Total Cholesterol", 
     ylab = "Frequency",  
     col = "gray", 
     las = 1)
```

Just as when plotting one overall histogram, we can change the y-axis to display the relative frequency within each subgroup. 

```{r, fig.align="center", fig.width=6}
h1 <- hist(grp1$TOTCHOL, 
           breaks = seq(100, 700, by=50),
           plot = FALSE)
h1$counts <- 100 * h1$counts / sum(h1$counts)   # relative frequency
h2 <- hist(grp2$TOTCHOL, 
           breaks = seq(100, 700, by=50), 
           plot = FALSE)
h2$counts <- 100 * h2$counts / sum(h2$counts)   # relative frequency

par(mfrow = c(1,2))   # figures will be plotted in 1 row, 2 columns

plot(h1, 
     main = "Not Overweight/Obese",
     xlab = "Total Cholesterol", 
     ylab = "Relative Frequency (%)",
     col = "gray", 
     las = 1)

plot(h2, 
     main = "Overweight/Obese",
     xlab = "Total Cholesterol", 
     ylab = "Relative Frequency (%)",
     col = "gray", 
     las = 1)        
```

To request one plot on top of the other, request a plot layout of 2 rows and 1 column using `par(mfrow=c(2,1))`.

```{r, fig.align="center", fig.width=6}
par(mfrow = c(2,1))   # figures will be plotted in 2 rows, 1 column

hist(grp1$TOTCHOL, 
     breaks = seq(100, 700, by=50), 
     main="Not Overweight/Obese", 
     xlab = "Total Cholesterol", 
     ylab="Frequency", 
     col = "gray", 
     las = 1)

hist(grp2$TOTCHOL, 
     breaks = seq(100, 700, by=50),
     main="Overweight/Obese", 
     xlab = "Total Cholesterol", 
     ylab="Frequency", 
     col = "gray", 
     las = 1)
```

We can plot **boxplots** separately by group using a formula statement to specify the quantitative variable being plotted followed by `~` and the grouping variable (a factor). 

```{r, out.width=c('50%', '50%'), fig.show='hold'}
boxplot(TOTCHOL ~ OVERWEIGHTOBESE_factor, data=fhs, 
        xlab = "Overweight/Obese",
        ylab = "Total Cholesterol",
        las = 1)

boxplot(TOTCHOL ~ OVERWEIGHTOBESE_factor, data=fhs, 
        xlab = "Total Cholesterol",
        ylab = "Overweight/Obese",
        horizontal = TRUE,
        las = 1)
```

We can look at combinations of two categorical variables crossing two grouping variables on the right hand side of the `~` in the formula statement. For example, if we are interested in presenting boxplots by sex within each overweight/obesity category use `SEX_factor*OVERWEIGHTOBESE_factor`: 

```{r, fig.align="center", fig.width=6}
boxplot(TOTCHOL ~ SEX_factor*OVERWEIGHTOBESE_factor, data=fhs, 
        xlab = "Sex:Overweight/Obese",
        ylab = "Total Cholesterol",
        las = 1)
```


# Categorical Variables

**Categorical variables** are typically summarized using frequency tables, cross-tabulations (a.k.a., contingency tables), and barplots.


## Numerical Summaries

A **frequency distribution** is summarized in a **frequency table**. Frequencies (counts) and relative frequencies (percentages) are commonly reported together. The relationship between two categorical variables is displayed using a **cross-tabulation.** 


### Overall

The `table()` function returns the number of observations in each category. We use the `dnn` option to assign a name to the variable displayed in the printed table. The `useNA` option (i.e., `useNA = "ifany"`) will display the `NA` category in the table if missing values are present.

```{r}
table(fhs$CIGPDAYGRP_factor, dnn = "Cigarettes Per Day")
table(fhs$CIGPDAYGRP_factor, dnn = "Cigarettes Per Day", useNA = "ifany")  # displays NA category
```

The `sort()` function applied to a table displays the table categories in ascending order (categories with lowest count first). The `decreasing = TRUE` option in the `sort()` function sorts in descending order. 

```{r}
tab <- table(fhs$CIGPDAYGRP_factor, dnn = "Cigarettes Per Day")
sort(tab)
sort(tab, decreasing = TRUE)
```

The `prop.table()` function returns the proportion of observations in each category. The argument of the `prop.table()` function must be a table object. Here, `table(fhs$CIGPDAYGRP_factor)` is saved as the object `tab` and we apply `prop.table()` to `tab`. 

```{r}
tab <- table(fhs$CIGPDAYGRP_factor, dnn = "Cigarettes Per Day")
prop.table(tab)
```

Again, the `useNA = "ifany"` option displays the NA category if missing values are present.

```{r}
prop.table(table(fhs$CIGPDAYGRP_factor, dnn = "Cigarettes Per Day", useNA = "ifany"))  # can nest functions
```

The `cumsum()` function returns the cumulative sum over the categories of a variable. Here, we apply `cumsum()` to the `relfreq` object, which is the table of relative frequencies.  The relative frequencies should sum to 1 over all categories.

```{r}
tab <- table(fhs$CIGPDAYGRP_factor)
relfreq <- prop.table(tab)
cumsum(relfreq)
```


----

<span style="color: #2980B9;">**Exercise**: Combine `prop.table()` and `cumsum()` to find the proportion of non-missing values of `CIGPDAYGRP_factor`.</span> 

----

<details><summary>Answer:</summary>

```{r}
tabNA <- table(fhs$CIGPDAYGRP_factor, dnn = "Cigarettes Per Day", useNA = "ifany")
relfreqNA <- prop.table(tabNA)
cumsum(relfreqNA)
```

> The proportion of non-missing values of grouped cigarettes/day is equal to `r round(cumsum(relfreqNA), 3)[4]`.

</details>  
\  
  

### By Group

The `table()` function can be used to create a cross-tabulation by specifying two factor variable arguments. The first variable is the row variable and the second variable is the column variable. Below, we are creating a cross-tabulation of `OVERWEIGHTOBESE_factor` by `SEX_factor`.  Specify labels to both table dimensions using a vector in the `dnn` option.

```{r}
table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor, dnn = c("Sex", "Overweight/Obese"))
```

The `rowSums()` and `colSums()` functions report the row and column totals, respectively.

```{r}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor, dnn = c("Sex", "Overweight/Obese"))
rowSums(tab)
colSums(tab)
```

The `prop.table()` function gives **cell proportions**.  The cell proportions in a table sum to 1.

```{r}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor, dnn = c("Sex", "Overweight/Obese"))
prop.table(tab)  # cell proportions
```

Often, we would like to look at the proportions within a fixed row or column.  Fixing the row and reporting the percentages in each column level gives **row proportions**. For example, out of all male patients, `r round(100*prop.table(table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor), margin=1)[1,2],2)`% are overweight/obese. Out of all female patients, `r round(100*prop.table(table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor), margin=1)[2,2],2)`% are overweight/obese. Row proportions are requested with the `margin = 1` option. Row proportions should sum to 1 in each row.

Likewise, fixing the column and reporting the percentages in each row level gives **column proportions**. In those who are overweight/obese, `r round(100*prop.table(table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor), margin=2)[1,2],2)`% are male and `r round(100*prop.table(table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor), margin=2)[2,2],2)`% are female. Column proportions are requested with the `margin = 2` option. Column proportions should sum to 1 in each column.

```{r}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor, dnn = c("Sex", "Cigarettes Per Day"))

prop.table(tab, margin = 1)  # row proportions
rowSums(prop.table(tab, margin = 1))

prop.table(tab, margin = 2)  # column proportions
colSums(prop.table(tab, margin = 2))
```


## Graphical Summaries

**Barplots** are used as a visual representation of a frequency distribution.


### Overall

Barplots are created using the `barplot()` function. The function is applied to a table object. By default, a vertical barplot is produced. The option `horiz = TRUE` creates a horizontal barplot.

If the table plotted is a frequency table, then counts are plotted on the y-axis.

```{r, fig.align="center", fig.width=6, fig.cap="Distribution of FHS Participants by Sex"}
tab <- table(fhs$SEX_factor)
barplot(tab, 
        main = "",    # title
        xlab = "Sex",
        ylab = "Frequency",
        las = 1)
```

If the table reports proportions, then proportions or relative frequencies are plotted on the y-axis.

```{r, fig.align="center", fig.width=6}
tab <- table(fhs$SEX_factor)
relfreq <- 100*prop.table(tab)
barplot(relfreq, 
        main = "",
        xlab = "Sex",
        ylab = "Relative Frequency (%)",
        las = 1)
```

Categories can be plotted in descending order by applying the `sort()` function to the table.

```{r, fig.align="center", fig.width=6}
tab <- sort(table(fhs$SEX_factor), decreasing = TRUE)
barplot(tab, 
        main = "",
        xlab = "Sex",
        ylab = "Frequency",
        las = 1)
```

We can use the `barplot()` function to produce what appears to be a histogram for use with ordinal variables by removing the spacing between bars with the `space = 0` option. 

```{r, fig.align="center", fig.width=6}
tab <- table(fhs$CIGPDAYGRP_factor)
barplot(tab, space = 0,
        main = "",
        xlab = "Cigarettes Smoked/Day",
        ylab = "Frequency",
        las = 1)
```

Again, if the table consists of relative frequencies, the y-axis will display relative frequencies:

```{r, fig.align="center", fig.width=6}
tab <- table(fhs$CIGPDAYGRP_factor)
relfreq <- 100*prop.table(tab)
barplot(relfreq, space = 0,
        main = "",
        xlab = "Cigarettes Smoked/Day",
        ylab = "Relative Frequency (%)",
        las = 1)
```


### By Group

We can create **grouped barplots** using contingency tables.  The column variable (second factor variable listed) will be placed on the x-axis and the row variable will be subgroups within each level of the column variable.

```{r, fig.align="center", fig.width=6, fig.cap="Distribution of Sex and Overweight/Obese Status"}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor)
tab

barplot(tab,
        main = "",
        xlab = "Overweight/Obese",
        ylab = "Frequency",
        ylim = c(0, 1500),  # increasing range of y-axis to accommodate legend
        beside = TRUE,
        col = c("gray", "skyblue2"),
        las = 1)

legend(x = "top", 
       legend = rownames(tab),  # legend text
       fill = c("gray", "skyblue2"), 
       bty = "n", # no box surrounding legend
       ncol = 2)  # number of columns in legend
```

In this case, it makes sense to report column percentages (i.e., for a given level of Overweight/Obese, what is the proportion of Males and the proportion of females).

```{r, fig.align="center", fig.width=6, fig.cap="Distribution of Sex and Overweight/Obese Status"}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor)
relfreq <- 100*prop.table(tab, margin = 2)
relfreq

barplot(relfreq,
        main = "",
        xlab = "Overweight/Obese",
        ylab = "Relative Frequency (%)",
        ylim = c(0, 75),  
        beside = TRUE,
        col = c("gray", "skyblue2"),
        las = 1)

legend(x = "top", 
       legend = rownames(tab), 
       fill = c("gray", "skyblue2"), 
       bty = "n", 
       ncol = 2)
```

We can similarly create **stacked barplots** by removing the `beside = TRUE` option:

```{r, fig.align="center", fig.width=6, fig.cap="Distribution of Sex and Overweight/Obese Status"}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor)

par(mar = c(5,4,4,8))  # changing the plot margins (increasing right margin to accommodate legend in margin)

barplot(tab,
        main = "",
        xlab = "Overweight/Obese",
        ylab = "Frequency",
        col = c("gray", "skyblue2"),
        las = 1)

legend(x = "right", 
       legend = rownames(tab), 
       fill = c("gray", "skyblue2"), 
       bty = "n", 
       xpd = TRUE,  # placement of legend in margin
       inset=c(-0.3, 0))  # adjustment to inset may be necessary for proper legend placement
```

**Mosaic plots** are useful for visualizing the data from the contingency table. The first variable (`SEX_factor`) is plotted along the x-axis and the second variable (`OVERWEIGHTOBESE_factor`) is plotted along the y-axis.

```{r, fig.align="center", fig.width=6}
tab <- table(fhs$SEX_factor, fhs$OVERWEIGHTOBESE_factor)
mosaicplot(tab, 
           main = "",
           xlab = "Sex",
           ylab = "Overweight/Obese")

mosaicplot(table(fhs$OVERWEIGHTOBESE_factor, fhs$SEX_factor),  # nest table within mosaicplot() function
           main = "",
           xlab = "Overweight/Obese",
           ylab = "Sex")
```


# (Bonus) If there's time during Lab: `tableby()`


## Quantitative Variables

The `tableby()`^[https://www.rdocumentation.org/packages/arsenal/versions/3.5.0/topics/tableby, https://cran.r-project.org/web/packages/arsenal/vignettes/tableby.html] function in the `arsenal` package can be used to create customized tables that can accommodate both quantitative and categorical variables. To create a simple table stratified by levels of a grouping variable (e.g., overweight/obese status), use a formula statement to specify the grouping variable (usually a factor) followed by `~` and the variables that you want summarized, each separated by `+`.  For example, `tableby(grouping_variable ~ var1 + var2 + var3 + ...)`. *Numeric variables* are summarized using default summary statistics such as mean, standard deviation and range; *character and factor variables* are summarized using default summary statistics such as count and percentage. Be sure to use the `results = "asis"` chunk option to display the formatted table in your output document.

First, we create the `tableby()` object (named `tab1`, below), then we run `summary(tab1)` to produce the table.

```{r, results = "asis"}
# Default tableby table summarizing some quantitative variables by group
tab1 <- tableby(OVERWEIGHTOBESE_factor ~ AGE + BMI + TOTCHOL + SYSBP+ DIABP + HEARTRTE + GLUCOSE + CIGPDAY, 
                test = FALSE, data = fhs)
summary(tab1, term.name = TRUE)  # term.name displays the factor label in the header
```

**Note:** To create a table for the overall sample (i.e., not stratified by a grouping variable), omit the `grouping_variable` from the `tableby()` function (i.e., `tableby( ~ var1 + var2 + var3 + ...)`).

By default, reported statistics for quantitative variables (`numeric.stats`) are `Nmiss`, `meansd`, and `range`, but the `tableby()` table can be customized.  Request different statistics in the `numeric.stats` option in the `tableby.control()` function: 

`numeric.stats = c(...)` |  `stats.labels = list(...)`    |
:-------------|:------------------------------------------|
`N`           | N = "Sample Size" | 
`Nmiss`       | Nmiss = "Missing" (only shows "Missing" row when missing values are present) |
`Nmiss2`      | Nmiss2 = "Missing" (always shows "Missing" row) |
`meansd`      | meansd = "Mean (SD)" |
`median`      | median = "Median" |
`medianrange` | medianrange = "Median (Range)" |
`medianq1q3`  | medianq1q3 = "Median (Q1, Q3)" |
`q1q3`        | q1q3 = "Q1, Q3" |
`iqr`         | iqr = "IQR" |
`mean`        | mean = "Mean" |
`sd`          | sd = "SD" |
`var`         | var = "Var" |
`max`         | max = "Max" |
`min`         | min = "Min" | 
`meanCI`      | meanCI = "Mean (CI)" |
`sum`         | sum = "Sum" |
`range`       | range = "Range" |
`Npct`        | Npct = "N (Pct)"; displays number (%) of non-missing observations in each category |
`countpct`    | countpct = "N (%)" (column percent); displays each value of the quantitative variable |

It is also possible to apply variable labels to make the output clearer to the reader (e.g., instead of displaying `TOTCHOL`, change the variable label of `TOTCHOL` to display as `Total Cholesterol` in the table). This is done using the object `my_labels` created below.

```{r, results = "asis"}
# Requesting specific statistics, specifying stat labels
my_controls <- tableby.control(
  test = F,             # do not display p-value comparing columns
  total = T,            # display Total column
  numeric.stats = c("Nmiss2", "meansd", "medianq1q3", "medianrange", "range"),    # requested stats
  cat.stats = c("Nmiss", "countpct"),
  stats.labels = list(
    Nmiss2 = "Missing",
    meansd = "Mean (SD)",
    medianq1q3 = "Median (Q1, Q3)",
    medianrange = "Median (Range)",
    range = "Min - Max",
    Nmiss = "Missing",
    countpct = "N (%)"
  ),
  digits = 1
)

# Labeling variables
my_labels <- list(
  AGE = "Age (years)",
  BMI = "Body Mass Index",
  TOTCHOL = "Total Cholesterol",
  SYSBP = "Systolic Blood Pressure",
  DIABP = "Diastolic Blood Pressure",
  OVERWEIGHTOBESE_factor = "Overweight or Obese"
)
 
# tableby(grouping_variable ~ variables to be summarized, separated by +)
table_one <- tableby(OVERWEIGHTOBESE_factor ~ AGE + BMI + TOTCHOL + SYSBP + DIABP,
  data = fhs,
  control = my_controls
)

# Produces table, adds title
summary(table_one,
  labelTranslations = my_labels,
  title = "Summary Statistics of FHS Data: Quantitative Variables",
  term.name = TRUE
)
```

Note that one would not normally display all three of the following: Median (Q1, Q3), Median (Range), and Min - Max.  


## Categorical Variables

The `tableby()` function in the `arsenal` package can be used to create tables that can accommodate both quantitative and categorical variables. As we did above when considering only quantitative variables, use a formula statement to specify the grouping variable followed by `~` and the character or factor variables that we want summarized, each separated by `+`.  For example, `grouping_variable ~ var1_factor + var2_factor + var3_factor`. Again, be sure to use the `results = "asis"` chunk option to display the formatted table in your output document.

```{r, results = "asis"}
# Default tableby table
tab1 <- tableby(OVERWEIGHTOBESE_factor ~ SEX_factor + CIGPDAYGRP_factor, 
                test = FALSE, data = fhs)
summary(tab1, term.name = TRUE)  # term.name displays the factor label in the header
```

The `includeNA()` function can be applied to categorical variables to include NAs in the counts and percents.

```{r, results = "asis"}
# Default tableby table with NA category n and % displayed
tab1 <- tableby(OVERWEIGHTOBESE_factor ~ includeNA(SEX_factor) + includeNA(CIGPDAYGRP_factor), 
                test = FALSE, data = fhs)
summary(tab1, term.name = TRUE)  
```

By default, reported statistics for categorical variables (`cat.stats`) are `Nmiss`, and `countpct`, but the `tableby()` table can be customized. Request different statistics in the `cat.stats` option in the `tableby.control()` function: 

`cat.stats = c(...)` |  `stats.labels = list(...)`    |
:-------------|:------------------------------------------|
`Nmiss`       | Nmiss = "Missing" (only shows "Missing" row when missing values are present) |
`Nmiss2`      | Nmiss2 = "Missing" (always shows "Missing" row) |
`count`       | count = "N" |
`countN`      | countN = "N/Total" |
`countpct`    | countpct = "N (%)" (column percent) |
`countrowpct` | countrowpct = "N (%)" (row percent) |
`countcellpct`| countcellpct = "N (%)" (cell percent) |

```{r, results = "asis"}
# Requesting specific statistics, specifying stat labels
my_controls <- tableby.control(
  test = F,
  total = T,
  numeric.stats = c("Nmiss2", "meansd", "medianq1q3", "medianrange", "range"),
  cat.stats = c("Nmiss", "countpct"),     # requested stats
  stats.labels = list(
    Nmiss2 = "Missing",
    meansd = "Mean (SD)",
    medianq1q3 = "Median (Q1, Q3)",
    medianrange = "Median (Range)",
    range = "Min - Max",
    Nmiss = "Missing",
    countpct = "N (%)"
    ),
  digits = 1
)

# Labeling variables
my_labels <- list(
  SEX_factor = "Sex",
  CIGPDAYGRP_factor = "Cigarettes per Day",
  OVERWEIGHTOBESE_factor = "Overweight or Obese"
)
 
# tableby(grouping_variable ~ variables to be summarized, separated by +)
table_one <- tableby(OVERWEIGHTOBESE_factor ~ SEX_factor + CIGPDAYGRP_factor,
  data = fhs,
  control = my_controls
)

# Produces table, adds title
summary(table_one,
  labelTranslations = my_labels,
  title = "Summary Statistics of FHS Data: Categorical Variables",
  term.name = TRUE
)
```


## All Variables

The nice thing about the `tableby()` function is that we can include both quantitative and categorical variables in the same table. *Numeric variables* are summarized by the `numeric.stats` and *character and factor variables* are summarized by the `cat.stats` requested in `tableby.control()`.

```{r, results = "asis"}
# Requesting specific statistics, specifying stat labels
my_controls <- tableby.control(
  test = F,
  total = T,
  numeric.stats = c("Nmiss2", "meansd", "medianrange"),  # requested stats
  cat.stats = c("Nmiss", "countpct"),                    # requested stats
  stats.labels = list(
    Nmiss2 = "Missing",
    meansd = "Mean (SD)",
    medianrange = "Median (Range)",
    Nmiss = "Missing",
    countpct = "N (%)"
  ),
  digits = 1
)

# Labeling variables
my_labels <- list(
  AGE = "Age (years)",
  BMI = "Body Mass Index",
  TOTCHOL = "Total Cholesterol",
  SYSBP = "Systolic Blood Pressure",
  DIABP = "Diastolic Blood Pressure",
  SEX_factor = "Sex",
  CIGPDAYGRP_factor = "Cigarettes per Day",
  OVERWEIGHTOBESE_factor = "Overweight or Obese"
)

# tableby(grouping_variable ~ variables to be summarized, separated by +)
table_one <- tableby(OVERWEIGHTOBESE_factor ~ AGE + SEX_factor + BMI + CIGPDAYGRP_factor + TOTCHOL + SYSBP + DIABP,
  data = fhs,
  control = my_controls
)

# Produces table, adds title
summary(table_one,
  labelTranslations = my_labels,
  title = "Summary Statistics of FHS Data: All Variables",
  term.name = TRUE
)
```

