---
title: "Lab 7 BIS 505b"
author: "Maria Ciarleglio"
date: "4/12/2021"
output: 
    html_document:
        toc: true
        highlight: default
---

<!--- Copyright (c) 2021, M. Ciarleglio --->

<!--- Set global options --->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
#options(scipen=999)               # global option that requests no scientific notation in this session
options(show.signif.stars=FALSE)  # global option to hide significance stars 
```

<!--- Load packages --->
```{r, message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(ggplot2)
library(car)
library(MASS)
```

<!--- Set WD and read data file --->
```{r, include=FALSE}
#setwd("C:\\BIS_505\\LABS\\Lab7")  # modify path to your R Lab7 folder
vis <- read.csv("visits.csv")
```


# Goal of Lab 7

In **Lab 7**, we will analyze a **count endpoint** using **Poisson regression.**  We will begin by **(1)** numerically and graphically summarizing the response variable. Next, we will model the **(2)** count and the **(3)** rate outcome using a Poisson model. We will consider binary, continuous, and categorical predictors with $>2$ levels. We will **(4)** predict the mean count and the event rate from our fitted models, **(5)** determine if overdispersion is a problem in the data, and **(6)** fit a negative binomial regression model. 


# Analysis Data Set

In this lab, we will analyze data on the number of office-based doctor visits by adults aged 25-64 ($n$ = 4408) contained in `visits.csv`. This data set is imported as the data frame `vis` in code chunk 3 above. The **Data Key** is provided below. In this lab, our endpoint of interest is number of office visits (`visits`). The length of follow-up in months for each patient is recorded in the `followup` variable.


| Variable Name	| Definition |
|---------------|------------|
| `visits`      | Number of office-based doctor visits (**Our Response**) |
| `followup`    | Follow-up period (months) |
| `age`         | Age (years) |
| `educ`        | Years of schooling (12 = High school) |
| `income`      | Annual income (thousands of dollars) |
| `female`      | Indicator of female sex |
|               | &nbsp; 0 = Male |
|               | &nbsp; 1 = Female |
| `black`       | Indicator of black race |
|               | &nbsp; 0 = Non-black |
|               | &nbsp; 1 = Black |
| `hispanic`    | Indicator of Hispanic ethnicity |
|               | &nbsp; 0 = Non-Hispanic |
|               | &nbsp; 1 = Hispanic |
| `location`    | Location |
|               | &nbsp; 0 = West |
|               | &nbsp; 1 = Northeast |
|               | &nbsp; 2 = Midwest |
|               | &nbsp; 3 = South |
| `insured`     | Health insurance status |
|               | &nbsp; 0 = Uninsured |
|               | &nbsp; 1 = Insured |
| `chronic`     | Health status |
|               | &nbsp; 0 = No chronic conditions |
|               | &nbsp; 1 = Chronic conditions |



- **Creating Factor Variables:**

Next, we create factor variable versions of the **categorical variables** in this data set (`female`, `black`, `hispanic`, `location`, `private`, and `chronic`). The **first level** specified in the `factor()` function is the **reference level** of the variable.

```{r}
# Creating factor variables in vis using mutate() function in "dplyr" package
vis <- mutate(vis,
              female_factor = factor(female,
                                     levels = c(0, 1),
                                     labels = c("Male", "Female")),
              black_factor = factor(black,
                                    levels = c(0, 1),
                                    labels = c("Non-black", "Black")),
              hispanic_factor = factor(hispanic,
                                       levels = c(0, 1),
                                       labels = c("Non-Hispanic", "Hispanic")),
              location_factor = factor(location,
                                       levels = c(0, 1, 2, 3),
                                       labels = c("West", "Northeast", "Midwest", "South")),
              insured_factor = factor(insured,
                                      levels = c(0, 1),
                                      labels = c("Uninsured", "Insured")),
              chronic_factor = factor(chronic,
                                      levels = c(0, 1),
                                      labels = c("No chronic conditions", 
                                                 "1+ chronic conditions")))
```


# Research Questions

We are interested in identifying the characteristics that are associated with **number of doctor visits** `visits` (our response variable, $y$). We will study the effects of age (`age`), education (`educ`), sex (`female`), race (`black`), Hispanic ethnicity (`hispanic`), geographic location (`location`), health insurance status (`insured`), and health status (`chronic`) on the response. The differing lengths of follow-up for each patient should be accounted for in the analysis because a longer follow-up will likely give us the opportunity to observe a greater number of visits to the doctor. Looking at the **rate of doctor visits** will account for variable follow-up time.


# Summarizing Count and Rate Data

## Numerical Summaries

We can numerically summarize counts by reporting the estimated **mean count**, $\hat{\mu} = \dfrac{\sum\limits_{i=1}^n y_i}{n}$. When all individuals are not followed for the same length of time (i.e., there is **variable follow-up time**), we can take length of follow-up into account by estimating the **event rate**, $\hat{\lambda} = \dfrac{\sum\limits_{i=1}^n y_i}{\sum\limits_{i=1}^n t_i}$. Rates have units of number of events per unit of time (e.g., visits/month).

- **Summarizing the Count**

```{r}
# Mean and SD of number of doctor visits in full sample
c(mn = mean(vis$visits, na.rm=TRUE), std = sd(vis$visits, na.rm=TRUE), rnge = range(vis$visits, na.rm=TRUE))
```

On average, an individual in this sample visits the doctor $\hat{\mu} =$ `r round(mean(vis$visits, na.rm = TRUE),3)` times (SD = `r round(sd(vis$visits, na.rm = TRUE),3)`). The number of visits per subject has a wide range in these data-- from `r min(vis$visits, na.rm=TRUE)` visits to `r max(vis$visits, na.rm=TRUE)` visits. 

We can report mean number of doctor visits by levels of a factor variable such as insurance status (`insured_factor`), sex (`female_factor`), or presence of a chronic condition (`chronic_factor`).


  - *By Insurance Status*

```{r}
# Mean number of doctor visits by insurance status
aggregate(x = list(visits = vis$visits), by = list(group = vis$insured_factor), 
          FUN = function(x) c(mn=mean(x, na.rm=TRUE), std=sd(x, na.rm=TRUE)))
```

In this study, those *with insurance* visit the doctor an average of $\hat{\mu}_1 =$ `r round(mean(vis$visits[vis$insured_factor=="Insured"], na.rm=TRUE),3)` times, while those *without insurance* visit the doctor an average of $\hat{\mu}_0 =$ `r round(mean(vis$visits[vis$insured_factor=="Uninsured"], na.rm=TRUE),3)` times. 

```{r}
# Mean ratio (insurance vs. no insurance)
muhat1 <- mean(vis$visits[vis$insured_factor=="Insured"], na.rm=TRUE)
muhat0 <- mean(vis$visits[vis$insured_factor=="Uninsured"], na.rm=TRUE)
meanratio <- muhat1/muhat0
meanratio
```

The **ratio** of the mean number of visits in the insured group vs. uninsured group, or the estimated **mean ratio**, $\hat{\text{MR}}=\frac{\hat{\mu_1}}{\hat{\mu_0}}$, is equal to `r round(meanratio, 3)`, indicating that in this study, those *with insurance* visit the doctor `r round(meanratio, 3)` times more often than those *without insurance*.


  - *By Presence of Chronic Condition*
  
```{r}
# Mean number of doctor visits by presence of a chronic condition
aggregate(x = list(visits = vis$visits), by = list(group = vis$chronic_factor), 
          FUN = function(x) c(mn=mean(x, na.rm=TRUE), std=sd(x, na.rm=TRUE)))

# Mean ratio (chronic vs. no chronic)
muhat1 <- mean(vis$visits[vis$chronic_factor=="1+ chronic conditions"], na.rm=TRUE)
muhat0 <- mean(vis$visits[vis$chronic_factor=="No chronic conditions"], na.rm=TRUE)
meanratio <- muhat1/muhat0
meanratio
```

In this study, those with *at least one chronic condition* visit the doctor an average of $\hat{\mu}_1 =$ `r round(mean(vis$visits[vis$chronic_factor=="1+ chronic conditions"], na.rm=TRUE),3)` times, while those *with no chronic conditions* visit the doctor an average of $\hat{\mu}_0 =$ `r round(mean(vis$visits[vis$chronic_factor=="No chronic conditions"], na.rm=TRUE),3)` times. Those with *at least one chronic condition* visit the doctor `r round(meanratio, 3)` times more often than those with *no chronic conditions*.

----

<span style="color: #2980B9;">**Exercise**: Report mean number of doctor visits by sex and the mean ratio of doctor visits in females vs. males.
</span> 

----

<details><summary>Answer:</summary>

```{r}
# Mean number of doctor visits by sex
aggregate(x = list(visits = vis$visits), by = list(group = vis$female_factor), 
          FUN = function(x) c(mn=mean(x, na.rm=TRUE), std=sd(x, na.rm=TRUE)))

# Mean ratio (female vs. male)
muhat1 <- mean(vis$visits[vis$female_factor=="Female"], na.rm=TRUE)
muhat0 <- mean(vis$visits[vis$female_factor=="Male"], na.rm=TRUE)
meanratio <- muhat1/muhat0
meanratio
```

> In this study, females visit the doctor an average of $\hat{\mu}_1 =$ `r round(mean(vis$visits[vis$female_factor=="Female"], na.rm=TRUE),3)` times; males visit the doctor an average of $\hat{\mu}_0 =$ `r round(mean(vis$visits[vis$female_factor=="Male"], na.rm=TRUE),3)` times. *Females* visit the doctor `r round(meanratio, 3)` times more often than *males*.
</details>
\


- **Summarizing the Rate**

A common type of **rate** reports the number of events per unit of time, which accounts for the amount of individual follow-up time. The denominator of the rate is the total amount of time at risk for all subjects being followed. Follow-up time for individuals in this study varies from `r round(min(vis$followup, na.rm=TRUE),3)` to `r round(max(vis$followup, na.rm=TRUE),3)` months and the total follow-up time is equal to `r format(round(sum(vis$followup, na.rm=TRUE),3), scientific=FALSE)` person-months. 

```{r}
# Range of follow-up time in this study (months)
range(vis$followup, na.rm = TRUE)
```

Following individuals for a longer period of time gives you greater opportunity to observe (and count) a visit to the doctor. As we see in the scatterplot below, those with a larger number of visits tend to have a longer follow-up. 

```{r, fig.align="center", out.width='50%', message=FALSE}
# Scatterplot of number of follow-up time (months) vs. number of visits by insurance status
ggplot(data = vis, aes(x = visits, y = followup, 
                       color = insured_factor)) +                # color dots by insured_factor
  geom_point(size = 3, shape = 19, alpha = 0.3) + 
  labs(title = "Scatter Plot of Follow-up Time vs. Visits by Insurance Status", 
       x = "Number of Visits", y = "Follow-Up Time (months)") + 
  theme(legend.title = element_blank()) +                        # suppress legend title
  scale_color_manual(values = c("red", "blue")) # dot color for each level of insurance status
```

We can calculate average follow-up time in the groups examined above. 

```{r}
# Mean follow-up time by insurance status
aggregate(x = list(followup = vis$followup), by = list(group = vis$insured_factor), 
          FUN = function(x) c(mn=mean(x, na.rm=TRUE), rnge=range(x, na.rm=TRUE)))
```

Although those with medical insurance have a larger average number of doctor visits compared to those without medical insurance, the average length of follow-up is similar in the two groups: `r round(mean(vis$followup[which(vis$insured_factor=="Insured")], na.rm=TRUE),3)` months in those *with insurance* vs. `r round(mean(vis$followup[which(vis$insured_factor=="Uninsured")], na.rm=TRUE),3)` months in those *without insurance*.

To compute the **visit rate** in the overall sample, we divide the total number of events (`r format(round(sum(vis$visits, na.rm=TRUE),3), scientific=F)` visits) by the total follow-up time (`r format(round(sum(vis$followup, na.rm=TRUE),3), scientific=F)` person-months). 

```{r}
# Rate of doctor visits in the full sample, lambda.hat
overall.rate <- sum(vis$visits, na.rm = TRUE)/sum(vis$followup, na.rm = TRUE)
overall.rate
```

The **rate** of doctor visits in the sample is $\hat{\lambda} =$ `r round(overall.rate, 3)` visits/month. We can similarly compute the rate within levels of a factor variable. 


  - *By Insurance Status*

```{r}
# Rate of doctor visits by insurance status
bygroup.sum <- aggregate(x = list(visits = vis$visits, followup = vis$followup), 
                         by = list(group = vis$insured_factor),
                         FUN = sum, na.rm = TRUE)

bygroup.rate <- cbind(bygroup.sum, rate = bygroup.sum[,2]/bygroup.sum[,3])
bygroup.rate

# Rate ratio (insured vs. uninsured)
lamhat1 <- sum(vis$visits[vis$insured_factor=="Insured"], na.rm=TRUE)/
  sum(vis$followup[vis$insured_factor=="Insured"], na.rm=TRUE)
lamhat0 <- sum(vis$visits[vis$insured_factor=="Uninsured"], na.rm=TRUE)/
  sum(vis$followup[vis$insured_factor=="Uninsured"], na.rm=TRUE)
rateratio <- lamhat1/lamhat0
rateratio
```

In this study, those *with insurance* have a doctor visit rate of $\hat{\lambda}_1 =$ `r round(bygroup.rate[2,4],3)` visits/month, while those *without insurance* have a doctor visit rate of $\hat{\lambda}_0 =$ `r round(bygroup.rate[1,4],3)` visits/month. The **ratio** of the monthly rates in the insured vs. the uninsured group, or the **rate ratio**, $\hat{\text{RR}}=\frac{\hat{\lambda_1}}{\hat{\lambda_0}}$, is equal to `r round(rateratio, 3)`, indicating that those *with insurance* have `r round(rateratio, 3)` times the rate of doctor visits compared to those *without insurance*.


## Graphical Summary - Barplot

We can graphically summarize count data using a histogram or a barplot. Recall that plotting with `ggplot()` involves adding layers of plot elements to your plot area. Since we've already covered the syntax for using `ggplot()` to create a **histogram** in **Lab 4**, today we will focus on the **R** syntax for creating **barplots** of the discrete event counts.  Barplots are typically used to describe the frequency or relative frequency of observations within levels of a categorical (factor) variable. For example, a barplot is a good way to visually describe the frequency distribution of race. Barplots can be reported in the overall sample, in a subset of your sample, or by levels of another grouping variable such as exposure status. Here, we are going to create a barplot of the discrete number of visits to the doctor observed in the full sample and stratified by insurance status.

The functions `geom_bar()` and `geom_col()` can be used to create frequency and relative frequency barplots. `geom_bar()` makes the height of the bar proportional to the number of observations in each group `y=stat(count)`, while `geom_col()` makes the height of the bar represent values in the data frame. In the plot aesthetic (`aes()`), specify the x-variable as the count variable (i.e., `x=visits`) and specify the height of the bar as number of observations using `y=stat(count)`. The `stat()` function tells `ggplot()` that a calculated aesthetic value produced by the statistic will be used. In the example below, the height of the bar (the y-value) will equal the number subjects with 0, 1, 2, etc. doctor visits. 

We can further customize the barplot using the following options:

Option | Syntax in `geom_bar()`
---|---------
Bar width              | `width=`
Bar fill color         | `fill=`
Bar outline color      | `col=`
Bar transparency       | `alpha=` (`0` = transparent - `1` = solid)
Bar outline line type  | `linetype=` (`1` = solid, `2` = dashed)
Grouped bar position   | `position=position_dodge()`
Legend (if applicable) | `show.legend=` (`TRUE` or `FALSE`)

The width, bar outline color, and transparency of the bars can be specified using the options `width=`, `col=`, and `alpha=` in the `geom_bar()` function. To specify a constant bar fill color that is different from the default color of gray, specify `fill=` in the `geom_bar()` function instead of in the `ggplot()` `aes()`. For example, `fill="blue"` will produce blue bars.

```{r, out.width=c('50%', '50%'), fig.show='hold', message=FALSE}
# Basic frequency barplot 
ggplot(data = vis, aes(x = visits, y = stat(count))) +  
  geom_bar() 

# With customization:
ggplot(data = vis, aes(x = visits, y = stat(count))) +  
  geom_bar(fill = "blue", width = 0.7, alpha = 0.35) +  
  labs(title = "Frequency Barplot of Number of Visits to the Doctor", 
       x = "Number of Visits", y = "Count")
```

To report a relative frequency barplot, change the `y=` value in the original aesthetic to `y=100*(stat(count))/sum(stat(count))`.

```{r, fig.align="center", out.width='50%', message=FALSE}
# Relative frequency (%) barplot 
ggplot(data = vis, aes(x = visits, y = 100*(stat(count))/sum(stat(count)))) +  
  geom_bar(fill = "blue", width = 0.7, alpha = 0.35) +  
  labs(title = "Relative Frequency Barplot of Number of Visits to the Doctor", 
       x = "Number of Visits", y = "Relative Frequency (%)")
```

An option for creating plots by group is to create **panel plots**, in which the plot for each group is presented in a different panel. To create panel plots of for each level of `insured_factor` (i.e., insured vs. uninsured) add a `facet_wrap()` layer using the syntax `+ facet_wrap(~ insured_factor)`. Panels can be horizontal (left plot) or vertical (right plot). 

```{r, out.width=c('50%', '50%'), fig.show='hold', message=FALSE}
# Horizontal panel plots by group
ggplot(data = vis, aes(x = visits, y = stat(count))) +  
  geom_bar(fill = "blue", width = 0.7, alpha = 0.35) +  
  labs(title = "Frequency Barplot of Number of Visits to the Doctor", 
       x = "Number of Visits", y = "Count") +
  facet_wrap(~ insured_factor, ncol = 1)      # plots on top of each other (one column)

# Vertical panel plots by group
ggplot(data = vis, aes(x = visits, y = stat(count))) +  
  geom_bar(fill = "blue", width = 0.7, alpha = 0.35) +  
  labs(title = "Frequency Barplot of Number of Visits to the Doctor", 
       x = "Number of Visits", y = "Count") +
  facet_wrap(~ insured_factor, nrow = 1)      # plots side-by-side (one row)
```

As we can see, the counts are heavily **right skewed**. There are a few individuals with a large observed number of visits, giving the distribution of `visits` a long right tail.


# Poisson Regression of the Count

**Poisson regression** is a log-linear model that can be used to model a count $Y = \{0, 1, 2, \ldots\}$ response. A **Poisson distribution** is a **discrete** probability distribution describing the probability that a given number of events occur in a fixed period of time. The mean and variance of a Poisson random variable are both equal to $\mu$. When modeling a Poisson outcome $Y$, we assume the mean of $Y$ (i.e., $\mu$) is related to the linear function of the covariates $\alpha + \beta \, x$ (a.k.a., the *linear predictor*) through the **log function**, giving the following log-linear regression model:

$$ \log (\mu) = \alpha + \beta_1 \, x_1 + \beta_2 \, x_2 + \ldots + \beta_k \, x_k $$
Thus, the *link function* in Poisson regression is the $\log$ function since the log function links $\mu$ to $\alpha + \beta \, x$. The model of the count is estimated to give $\log (\hat{\mu}) = a + b_1 \, x_1 + b_2 \, x_2 + \ldots + b_k \, x_k$.

- The estimated intercept $a$ is equal to the estimated **log-mean number of events** (i.e., visits to the doctor) when all values of $x = 0$. 
- The estimated slope $b_j$ is equal to the estimated **log-mean ratio** associated with a 1-unit increase in $x_j$ controlling for or holding all other predictors constant. We must **exponentiate** the slope to find the estimated **mean ratio** (i.e., $\hat{\text{MR}} = e^{b_j}$).

A **hypothesis test** of the slope parameter $H_0: \beta_j = 0$ vs. $H_1: \beta_j \neq 0$ is performed using a **Wald test**, $z = \frac{b_j}{s_{b_j}}$, which is compared to a **standard Normal distribution**. Under $H_0$, $\beta_j = 0$, there is no association between $x_j$ and the outcome. When the $\log(MR) = 0$, the $MR = e^0 = 1$.

The estimated or predicted or fitted mean count $\hat{\mu}$ is equal to $\hat{\mu} = e^{a + b_1 \, x_1 + b_2 \, x_2 + \ldots + b_k \, x_k}$.

We use the `glm()` function in **R** to run a Poisson regression model. A Poisson regression model is specified through the function argument `family = poisson(link = "log")`.

`glm()` Function Arguments | Option Definition
---|---------
`formula=` | `analysis_variable ~ predictor_variable1 + predictor_variable2` |
`data=`    | Data frame containing sample data |
`family=`  | Error distribution and link function |
&nbsp;     | &nbsp; - Poisson regression `=poisson(link="log")` |
&nbsp;     | &nbsp; - Logistic regression `=binomial(link="logit")` |
&nbsp;     | &nbsp; - Linear regression `=gaussian(link="identity")` |


In our doctor visit data, since all subjects are not followed for the same length of time, it is more appropriate to account for follow-up time by analyzing the **rate** rather than analyzing the **count**.  We will discuss analyzing the **rate** in the next section. However, we will create a Poisson model of the count as an illustration of how to analyze and interpret this type of model. A model of the count would have been appropriate if all of the individuals in this data set had been followed for a fixed period of time (e.g., number of doctor visits over a fixed 1-year period). 


## Simple Poisson Regression of the Count

We begin by fitting an **unadjusted Poisson model of the count** using insurance status (`insured_factor`) as the only predictor. We would like to determine if there is an association between the insurance status and the average number of visits to the doctor. In other words, is there a significant difference in the average number of doctor visits in those who have insurance vs. those who do not have insurance (reference group). 

The `contrasts()` function returns the dummy variable coding that **R** uses to represent a factor variable. For example, `insured_factor` is a dummy variable ($z_1$) that equals `1` for those who are insured and `0` for those who are uninsured (the reference category). 

```{r}
contrasts(vis$insured_factor)
```

To estimate the association between **number of visits to the doctor** (`visits`) and **insurance status** (`insured_factor`), fit the Poisson regression model, $\log (\mu) = \alpha + \beta_1 \, \text{Insured}$. The result of the `glm()` function is usually saved as an object (`mod.mean1`, below) and the `summary()` function is applied to that object (`summary(mod.mean1)`) to output detailed results. 
```{r}
# Poisson regression of the count
mod.mean1 <- glm(visits ~ insured_factor, data = vis, family = poisson(link="log"))
summary(mod.mean1)
```

We can extract the **model coefficients** ($a$, $b_1$) using the `coef()` function and the **confidence intervals** of the model parameters ($\alpha$, $\beta_1$) using the `confint.default()` function. Remember that we must exponentiate $b_1$ to give an estimate of the mean ratio. Similarly, we must exponentiate the confidence interval for $\beta_1$ to give a confidence interval for the mean ratio, $e^{\beta_1}$.

```{r}
# Slope coefficient = logMR, exponentiated slope coefficient = MR and 95% CI for MR
round(cbind(bj=coef(mod.mean1), MR=exp(coef(mod.mean1)), exp(confint.default(mod.mean1))), 5)
```

- The **fitted model** is given by the equation, $\log (\hat{\mu}) =$ `r round(coef(mod.mean1)[1],3)` `r ifelse(summary(mod.mean1)$coefficients[2]<0,"$-$","$+$")` `r round(abs(summary(mod.mean1)$coefficients[2]),3)` Insured 

- The **estimated intercept** $a =$ `r round(summary(mod.mean1)$coefficients[1],3)` is equal to the *log-mean number of doctor visits* when $z_1 = 0$ (i.e., the *log-mean number of doctor visits* in the reference category (the *uninsured*)). The exponentiated intercept $e^{a}=$ `r round(exp(summary(mod.mean1)$coefficients[1]),3)` is equal to the *mean number of doctor visits* in those without insurance. We computed this mean when we summarized the counts by group in **Section 4** of this Lab using the `aggregate()` function.

- The **estimated slope** of `insured_factor` $b_1 =$ `r round(summary(mod.mean1)$coefficients[2],3)` is equal to the *log-mean ratio* of the number of doctor visits in the *insured* vs. the *uninsured* (ref). The exponentiated slope $e^{b_1}$ gives the estimated **mean ratio**, $\hat{MR} = e^{b_1} =$ `r round(exp(summary(mod.mean1)$coefficients[2]),2)` [95% CI (`r round(exp(confint.default(mod.mean1)[2,1]),2)`, `r round(exp(confint.default(mod.mean1)[2,2]),2)`)]. In this study, those who are insured had `r round(exp(summary(mod.mean1)$coefficients[2]),2)` times the number of doctor visits, on average, compared to those who are uninsured.  We also computed this mean ratio using the raw data in **Section 4** above.

- A **significance test of the slope** ($H_0: \beta_1=0$ vs. $\beta_1 \neq 0$) reports a z-statistic z = `r round(summary(mod.mean1)$coefficients[6],2)`, which is compared to a standard Normal distribution. We have evidence to reject $H_0$ and conclude that the mean number of doctor visits is significantly different in those with health insurance and those without health insurance (p-value `r ifelse(summary(mod.mean1)$coefficients[8]<.001,"<.001",paste("=",round(summary(mod.mean1)$coefficients[8],3)))`). 

----

<span style="color: #2980B9;">**Exercise**: Construct a simple Poisson regression model of the count to determine if there is an association between number of doctor visits and sex. Report and interpret the mean ratio in females vs. males.
</span> 

----

<details><summary>Answer:</summary>

```{r}
mod.meansex <- glm(visits ~ female_factor, data = vis, family = poisson(link="log"))
summary(mod.meansex)
round(cbind(bj=coef(mod.meansex), MR=exp(coef(mod.meansex)), exp(confint.default(mod.meansex))), 5)
```

> There is a significant association between sex and number of doctor visits. That is, the mean number of doctor visits is significantly different in males and females (p-value `r ifelse(summary(mod.meansex)$coefficients[8]<.001,"<.001",paste("=",round(summary(mod.meansex)$coefficients[8],3)))`).  
> The estimated **mean ratio**, $\hat{MR} = e^{b_1} =$ `r round(exp(summary(mod.meansex)$coefficients[2]),2)`. In this study, females had `r round(exp(summary(mod.meansex)$coefficients[2]),2)` times the number of doctor visits, on average, compared to males.
</details>
\


## Fitted Mean Count

The **fitted model** can be used to **estimate or predict the mean number of doctor visits** $\mu$ for given values of $x$ (`insured_factor`) using the `predict()` function. A data frame that contains the values of $x$ for which we would like to calculate $\hat{\mu}$ must be specified in the `newdata=` argument of the `predict()` function. The values of $x$ of interest (i.e., `insured_factor` = "Uninsured" and "Insured") are stored in the data frame `pred.x`. 

```{r}
# Data frame that includes desired values of "x" for prediction
levels(vis$insured_factor)
pred.x <- data.frame(insured_factor = levels(vis$insured_factor))

# Equivalently,
pred.x <- data.frame(insured_factor = c("Uninsured", "Insured"))

# Returns estimated means
muhat <- predict(mod.mean1, newdata = pred.x, type = "response")
cbind(pred.x, muhat)
```

- The **estimated mean number of doctor visits** in an **uninsured** individual is equal to $\hat{\mu}_0=$ `r round(muhat[1],3)`.
- The **estimated mean number of doctor visits** in an **insured** individual is equal to $\hat{\mu}_1=$ `r round(muhat[2],3)`.
- These model-estimated fitted values are equal to the raw mean number of doctor visits observed in each group:

```{r}
# Mean number of doctor visits by insurance status
aggregate(x = list(visits = vis$visits), by = list(group = vis$insured_factor), 
          FUN = mean, na.rm = TRUE)
```


## Multiple Poisson Regression of the Count

Next, we extend this model to include age (`age`), education level (`educ`), sex (`female_factor`), race (`black_factor`), Hispanic ethnicity (`hispanic_factor`), geographic location (`location_factor`) and presence of chronic conditions (`chronic_factor`). `age` and `educ` are quantitative variables; `female_factor` (ref = "Male"), `black_factor` (ref = "Non-black"), `hispanic_factor` (ref = "Non-Hispanic"), and `chronic_factor` (ref = "No chronic conditions") are dichotomous variables; and `location_factor` is a 4-level categorical variable represented by 3 dummy variables (ref = "West"). 

```{r}
# Poisson regression of the count
mod.mean2 <- glm(visits ~ age + educ + female_factor + black_factor + hispanic_factor + 
                 location_factor + insured_factor + chronic_factor, data = vis, 
                 family = poisson(link="log"))
summary(mod.mean2)

# Slope coefficient = logMR, exponentiated slope coefficient = MR and 95% CI for MR
round(cbind(bj=coef(mod.mean2), MR=exp(coef(mod.mean2)), exp(confint.default(mod.mean2))), 5)
```

- The **fitted model** is given by the equation, $\log (\hat{\mu}) =$ `r round(coef(mod.mean2)[1],4)` `r ifelse(summary(mod.mean2)$coefficients[2]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[2]),3)` Age `r ifelse(summary(mod.mean2)$coefficients[3]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[3]),3)` Education `r ifelse(summary(mod.mean2)$coefficients[4]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[4]),3)` Female `r ifelse(summary(mod.mean2)$coefficients[5]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[5]),3)` Black `r ifelse(summary(mod.mean2)$coefficients[6]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[6]),3)` Hispanic `r ifelse(summary(mod.mean2)$coefficients[7]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[7]),3)` NE `r ifelse(summary(mod.mean2)$coefficients[8]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[8]),3)` MW  `r ifelse(summary(mod.mean2)$coefficients[9]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[9]),3)` South `r ifelse(summary(mod.mean2)$coefficients[10]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[10]),3)` Insured `r ifelse(summary(mod.mean2)$coefficients[11]<0,"$-$","$+$")` `r round(abs(summary(mod.mean2)$coefficients[11]),3)` ChronicConditions  

- Wald tests of the individual slopes show that there is evidence to reject $H_0: \beta_j = 0$ for all parameters except the indicator for Midwest geographic location (i.e., controlling for all other variables in the model, the mean number of visits to the doctor is not significantly different in those in the Midwest vs. those in the West (reference)) (p-value `r ifelse(summary(mod.mean2)$coefficients[41]<.001,"<.001",paste("=",round(summary(mod.mean2)$coefficients[41],3)))`). 

*Controlling for all of the other variables in the model...* 

- As **age** increases, the mean number of doctor visits increases. A 1-year increase in age increases the mean number of doctor visits by `r round(100*(exp(summary(mod.mean2)$coefficients[2])-1),0)`%; adjusted $\hat{MR}= e^{b_1} =$ `r round(exp(summary(mod.mean2)$coefficients[2]),3)` [95% CI (`r round(exp(confint.default(mod.mean2)[2,1]),3)`, `r round(exp(confint.default(mod.mean2)[2,2]),3)`)].

- As **years of education** increase, the mean number of doctor visits increases. A 1-year increase in education level increases the mean number of doctor visits by `r round(100*(exp(summary(mod.mean2)$coefficients[3])-1),0)`%, adjusted $\hat{MR}= e^{b_2} =$ `r round(exp(summary(mod.mean2)$coefficients[3]),3)` [95% CI (`r round(exp(confint.default(mod.mean2)[3,1]),3)`, `r round(exp(confint.default(mod.mean2)[3,2]),3)`)].

- The mean number of doctor visits in **females** is `r round(100*(exp(summary(mod.mean2)$coefficients[4])-1),0)`% higher than in *males* (ref); adjusted $\hat{MR}= e^{b_3} =$ `r round(exp(summary(mod.mean2)$coefficients[4]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[4,1]),2)`, `r round(exp(confint.default(mod.mean2)[4,2]),2)`)].

- The mean number of doctor visits in **blacks** is `r round(100*(1-exp(summary(mod.mean2)$coefficients[5])),0)`% lower than in *non-blacks* (ref); adjusted $\hat{MR}= e^{b_4} =$ `r round(exp(summary(mod.mean2)$coefficients[5]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[5,1]),2)`, `r round(exp(confint.default(mod.mean2)[5,2]),2)`)].

- The mean number of doctor visits in **Hispanics** is `r round(100*(1-exp(summary(mod.mean2)$coefficients[6])),0)`% lower than in *non-Hispanics* (ref); adjusted $\hat{MR}= e^{b_5} =$ `r round(exp(summary(mod.mean2)$coefficients[6]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[6,1]),2)`, `r round(exp(confint.default(mod.mean2)[6,2]),2)`)].

- The mean number of doctor visits in the **Northeast** is `r round(100*(exp(summary(mod.mean2)$coefficients[7])-1),0)`% higher than in the *West* (ref); adjusted $\hat{MR}= e^{b_6} =$ `r round(exp(summary(mod.mean2)$coefficients[7]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[7,1]),2)`, `r round(exp(confint.default(mod.mean2)[7,2]),2)`)].

- The mean number of doctor visits in the **Midwest** is `r round(100*(1-exp(summary(mod.mean2)$coefficients[8])),0)`% lower than in the *West* (ref); adjusted $\hat{MR}= e^{b_7} =$ `r round(exp(summary(mod.mean2)$coefficients[8]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[8,1]),2)`, `r round(exp(confint.default(mod.mean2)[8,2]),2)`)], (p-value `r ifelse(summary(mod.mean2)$coefficients[41]<.001,"<.001",paste("=",round(summary(mod.mean2)$coefficients[41],3)))`). 

- The mean number of doctor visits in the **South** is `r round(100*(1-exp(summary(mod.mean2)$coefficients[9])),0)`% lower than in the *West* (ref); adjusted $\hat{MR}= e^{b_8} =$ `r round(exp(summary(mod.mean2)$coefficients[9]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[9,1]),2)`, `r round(exp(confint.default(mod.mean2)[9,2]),2)`)].

- The mean number of doctor visits in the **insured** is `r round(100*(exp(summary(mod.mean2)$coefficients[10])-1),0)`% higher than in the *uninsured* (ref); adjusted $\hat{MR}= e^{b_9} =$ `r round(exp(summary(mod.mean2)$coefficients[10]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[10,1]),2)`, `r round(exp(confint.default(mod.mean2)[10,2]),2)`)].

- The mean number of doctor visits in those with **1+ chronic condition** is `r round(100*(exp(summary(mod.mean2)$coefficients[11])-1),0)`% higher than in those with *no chronic conditions* (ref); adjusted $\hat{MR}= e^{b_{10}} =$ `r round(exp(summary(mod.mean2)$coefficients[11]),2)` [95% CI (`r round(exp(confint.default(mod.mean2)[11,1]),2)`, `r round(exp(confint.default(mod.mean2)[11,2]),2)`)].

The estimated or **predicted mean number of doctor visits** in an individual with covariate values `age = 50`, `educ = 12`, `female_factor = "Male"`, `black_factor = "Non-black"`, `hispanic_factor = "Hispanic"`, `location_factor = "Northeast"`, `insured_factor = "Insured"`, `chronic_factor = "No chronic conditions"` can be found using the `predict()` function:

```{r}
# Data frame that includes desired values of "x" for prediction
pred.x <- data.frame(age = 50, educ = 12, female_factor = "Male", black_factor = "Non-black", 
                     hispanic_factor = "Hispanic", location_factor = "Northeast", 
                     insured_factor = "Insured", chronic_factor = "No chronic conditions")

# Returns estimated mean
muhat <- predict(mod.mean2, newdata = pred.x, type = "response")
muhat
```

- According to our model, this individual is expected to visit the doctor `r round(muhat, 2)` times over the course of follow-up. 


# Poisson Regression of the Rate

When outcomes occur over time, it is more relevant to model the event **rate of occurrence** $\lambda$ than the raw count $\mu$. When a response count, $y$, has time at risk associated with it equal to $t$, the sample rate is equal to $\hat{\lambda} = y/t$. The expected value of $\lambda$ is equal to $\mu/t$. The **rate** of the event $\lambda$ is modeled using a log-linear model:

\begin{align*}
\log(\lambda) = \log \left(\dfrac{\mu}{t}\right) &= \alpha + \beta_1 \, x_1 + \beta_2 \, x_2 + \ldots + \beta_k \, x_k \\
\log(\mu) - \log(t) &= \alpha + \beta_1 \, x_1 + \beta_2 \, x_2 + \ldots + \beta_k \, x_k \\
\log(\mu) &= \alpha + \beta_1 \, x_1 + \beta_2 \, x_2 + \ldots + \beta_k \, x_k + \log(t)
\end{align*}

where $\log(t)$ is the **offset** term, or a term in the regression model that does not have an estimated parameter (i.e., the "slope" of $\log(t)$ is forced to equal 1). Thus, a model of the **rate** reduces to a model of the Poisson **count** with an adjustment or **offset** term $\log(t)$, that accounts for each individual's time at risk. In **R**, we specify the offset term on the right hand side of the model equation as `offset(log(followup))`, where `followup` is the time variable in the denominator of the rate. 

The model of the rate is estimated to give $\log (\hat{\lambda}) = a + b_1 \, x_1 + b_2 \, x_2 + \ldots + b_k \, x_k$.

- The estimated intercept $a$ is equal to the estimated **log-rate of events** (i.e., visits to the doctor per month) when all values of $x = 0$. 
- The estimated slope $b_j$ is equal to the estimated **log-rate ratio** associated with a 1-unit increase in $x_j$ controlling for or holding all other predictors constant. We must **exponentiate** the slope to find the estimated **rate ratio** (i.e., $\hat{\text{RR}} = e^{b_j}$).

A **hypothesis test** of the slope parameter $H_0: \beta_j = 0$ vs. $H_1: \beta_j \neq 0$ is performed using a **Wald test**, $z = \frac{b_j}{s_{b_j}}$, which is compared to a **standard Normal distribution**. Under $H_0$, $\beta_j = 0$, there is no association between $x_j$ and the rate of the event. When the $\log(RR) = 0$, the $RR = e^0 = 1$.

The estimated or predicted or fitted rate of the event $\hat{\lambda}$ is equal to $\hat{\lambda} = e^{a + b_1 \, x_1 + b_2 \, x_2 + \ldots + b_k \, x_k}$.


## Simple Poisson Regression of the Rate

We begin by re-fitting `mod.mean1` and running an **unadjusted Poisson model of the rate** using insurance status (`insured_factor`) as the only predictor. Here, we would like to determine if there is a significant association between insurance status and the rate of doctor visits. In other words, is there a significant difference in the rate of doctor visits (i.e., visits/month) in those who have insurance vs. those who do not have insurance (reference group).  To estimate the association between **rate of doctor visits** (`visits`) and **insurance status** (`insured_factor`), fit the Poisson regression model, $\log (\lambda) = \alpha + \beta_1 \, \text{Insured}$, or $\log (\mu) = \alpha + \beta_1 \, \text{Insured} + \log(\text{Followup})$. 

```{r}
# Poisson regression of the rate
mod.rate1 <- glm(visits ~ insured_factor + offset(log(followup)), data = vis, 
                 family = poisson(link="log"))
summary(mod.rate1)

# Slope coefficient = logRR, exponentiated slope coefficient = RR and 95% CI for RR
round(cbind(bj=coef(mod.rate1), RR=exp(coef(mod.rate1)), exp(confint.default(mod.rate1))), 5)
```

Notice that we do not see the offset term in the list of estimated model coefficients. This is because the coefficient of $\log(\text{Followup})$ is not estimated and is fixed at 1.

- The **fitted model** is given by the equation, $\log (\hat{\lambda}) =$ `r round(coef(mod.rate1)[1],3)` `r ifelse(summary(mod.rate1)$coefficients[2]<0,"$-$","$+$")` `r round(abs(summary(mod.rate1)$coefficients[2]),3)` Insured 

- The **estimated intercept** $a =$ `r round(summary(mod.rate1)$coefficients[1],3)` is equal to the *log-rate of doctor visits* (i.e., visits/month) in the reference category (the *uninsured*). The exponentiated intercept $e^{a}=$ `r round(exp(summary(mod.rate1)$coefficients[1]),3)` visits/month is equal to the *monthly rate of doctor visits* in those without insurance. We computed this rate when we summarized the rates by group in **Section 4** of this Lab.

- The **estimated slope** of `insured_factor` $b_1 =$ `r round(summary(mod.rate1)$coefficients[2],3)` is equal to the *log-rate ratio* of doctor visits in the *insured* vs. the *uninsured* (ref). The exponentiated slope $e^{b_1}$ gives the estimated **rate ratio**, $\hat{RR} = e^{b_1} =$ `r round(exp(summary(mod.rate1)$coefficients[2]),2)` [95% CI (`r round(exp(confint.default(mod.rate1)[2,1]),2)`, `r round(exp(confint.default(mod.rate1)[2,2]),2)`)]. In this study, those who are insured had `r round(exp(summary(mod.rate1)$coefficients[2]),2)` times the rate of doctor visits of the uninsured.  We also computed this rate ratio using the raw data in **Section 4** above.

- A **significance test of the slope** ($H_0: \beta_1=0$ vs. $\beta_1 \neq 0$) reports a z-statistic z = `r round(summary(mod.rate1)$coefficients[6],2)`, which is compared to a standard Normal distribution. We have evidence to reject $H_0$ and conclude that the rate of doctor visits is significantly different in those with health insurance and those without health insurance (p-value `r ifelse(summary(mod.rate1)$coefficients[8]<.001,"<.001",paste("=",round(summary(mod.rate1)$coefficients[8],3)))`). 


----

<span style="color: #2980B9;">**Exercise**: Construct a simple Poisson regression model of the rate to determine if there is an association between the rate of doctor visits and sex. Report and interpret the rate ratio in females vs. males.
</span> 

----

<details><summary>Answer:</summary>

```{r}
mod.ratesex <- glm(visits ~ female_factor + offset(log(followup)), data = vis, family = poisson(link="log"))
summary(mod.ratesex)
round(cbind(bj=coef(mod.ratesex), MR=exp(coef(mod.ratesex)), exp(confint.default(mod.ratesex))), 5)
```

> There is a significant association between sex and rate of doctor visits. That is, the rate of doctor visits is significantly different in males and females (p-value `r ifelse(summary(mod.ratesex)$coefficients[8]<.001,"<.001",paste("=",round(summary(mod.ratesex)$coefficients[8],3)))`).    
> The estimated **rate ratio**, $\hat{RR} = e^{b_1} =$ `r round(exp(summary(mod.ratesex)$coefficients[2]),2)`. In this study, the rate of doctor visits in females was `r round(exp(summary(mod.ratesex)$coefficients[2]),2)` times the rate of doctor visits in males.
</details>
\


## Fitted Rate

The **fitted model** can be used to **estimate or predict the rate of doctor visits** $\lambda$ for given values of $x$ (`insured_factor`) and a given length of follow-up (`followup`).

```{r}
# Data frame that includes desired values of "x" for prediction
pred.x <- data.frame(insured_factor = c("Uninsured", "Insured"), followup = 1)

# Returns estimated monthly rates
lambdahat <- predict(mod.rate1, newdata = pred.x, type = "response")
cbind(pred.x, lambdahat)
```

- The **estimated visit rate/month** in an **uninsured** individual equal to $\hat{\lambda}_0=$ `r round(lambdahat[1],3)` visits/month. In other words, an uninsured individual is expected to visit the doctor $\hat{\lambda}_0=$ `r round(lambdahat[1],3)` times/month.
- The **estimated visit rate/month** in an **insured** individual equal to $\hat{\lambda}_1=$ `r round(lambdahat[2],3)` visits/month. In other words, an uninsured individual is expected to visit the doctor $\hat{\lambda}_1=$ `r round(lambdahat[2],3)` times/month.
- These numbers are equal to the raw monthly rates computed earlier. 

**Note:** We can change the value of `followup` in the `pred.x` data frame to estimate the rate over a different period of time. Since follow-up time is measured on a scale of months, to estimate the **annual rate** of doctor visits, specify `followup = 12`. 

----

<span style="color: #2980B9;">**Exercise**: Report **annual rate** of doctor visits by in the insured and in the uninsured.
</span> 

----

<details><summary>Answer:</summary>

```{r}
# Data frame that includes desired values of "x" for prediction (1 year = 12 months)
pred.x <- data.frame(insured_factor = c("Uninsured", "Insured"), followup = 12)

# Returns estimated annual rates
lambdahat.year <- predict(mod.rate1, newdata = pred.x, type = "response")
cbind(pred.x, lambdahat.year)

RR.hat <- lambdahat.year[2]/lambdahat.year[1]
RR.hat
```

> Since the time scale of `followup` is in months, to estimate the **yearly** rate, specify `followup = 12`.  
> An uninsured individual is expected to visit the doctor $\hat{\lambda}_0=$ `r round(lambdahat.year[1],3)` times/year.  
> An insured individual is expected to visit the doctor $\hat{\lambda}_1=$ `r round(lambdahat.year[2],3)` times/year.  
> The yearly rate is equal to the monthly rate times 12.  
> Middle school (*maybe?*) unit conversion flashback: $\dfrac{1 \text{ visit}}{\text{ month}} \times \dfrac{12 \text{ months}}{1 \text{ year}} = \dfrac{12 \text{ visits}}{\text{year}}$
</details>
\


## Multiple Poisson Regression of the Rate

Just as we did when modeling the count, we now extend this model of the visit rate to include age (`age`), education level (`educ`), sex (`female_factor`), race (`black_factor`), Hispanic ethnicity (`hispanic_factor`), geographic location (`location_factor`) and presence of chronic conditions (`chronic_factor`). 

```{r}
# Poisson regression of the rate
mod.rate2 <- glm(visits ~ age + educ + female_factor + black_factor + hispanic_factor + 
                 location_factor + insured_factor + chronic_factor + offset(log(followup)), 
                 data = vis, family = poisson(link="log"))
summary(mod.rate2)

# Slope coefficient = logRR, exponentiated slope coefficient = RR and 95% CI for RR
round(cbind(bj=coef(mod.rate2), RR=exp(coef(mod.rate2)), exp(confint.default(mod.rate2))), 5)
```

- The **fitted model** is given by the equation, $\log (\hat{\lambda}) =$ `r round(coef(mod.rate2)[1],4)` `r ifelse(summary(mod.rate2)$coefficients[2]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[2]),3)` Age `r ifelse(summary(mod.rate2)$coefficients[3]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[3]),3)` Education `r ifelse(summary(mod.rate2)$coefficients[4]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[4]),3)` Female `r ifelse(summary(mod.rate2)$coefficients[5]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[5]),3)` Black `r ifelse(summary(mod.rate2)$coefficients[6]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[6]),3)` Hispanic `r ifelse(summary(mod.rate2)$coefficients[7]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[7]),3)` NE `r ifelse(summary(mod.rate2)$coefficients[8]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[8]),3)` MW  `r ifelse(summary(mod.rate2)$coefficients[9]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[9]),3)` South `r ifelse(summary(mod.rate2)$coefficients[10]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[10]),3)` Insured `r ifelse(summary(mod.rate2)$coefficients[11]<0,"$-$","$+$")` `r round(abs(summary(mod.rate2)$coefficients[11]),3)` ChronicConditions  

- Just as in the model of the count, the Wald tests of the individual slopes show that there is evidence to reject $H_0: \beta_j = 0$ for all parameters except the indicator for Midwest geographic location (i.e., the rate of doctor visits is not significantly different in those in the Midwest vs. those in the West (reference)) (p-value `r ifelse(summary(mod.rate2)$coefficients[41]<.001,"<.001",paste("=",round(summary(mod.rate2)$coefficients[41],3)))`). 

*Controlling for all of the other variables in the model...* 

- As **age** increases, the rate of doctor visits increases. A 1-year increase in age increases the rate of doctor visits by `r round(100*(exp(summary(mod.rate2)$coefficients[2])-1),0)`%; adjusted $\hat{RR}= e^{b_1} =$ `r round(exp(summary(mod.rate2)$coefficients[2]),3)` [95% CI (`r round(exp(confint.default(mod.rate2)[2,1]),3)`, `r round(exp(confint.default(mod.rate2)[2,2]),3)`)].

- As **years of education** increase, the rate of doctor visits increases. A 1-year increase in education level increases the rate of doctor visits by `r round(100*(exp(summary(mod.rate2)$coefficients[3])-1),0)`%, adjusted $\hat{RR}= e^{b_2} =$ `r round(exp(summary(mod.rate2)$coefficients[3]),3)` [95% CI (`r round(exp(confint.default(mod.rate2)[3,1]),3)`, `r round(exp(confint.default(mod.rate2)[3,2]),3)`)].

- The rate of doctor visits in **females** is `r round(100*(exp(summary(mod.rate2)$coefficients[4])-1),0)`% higher than in *males* (ref); adjusted $\hat{RR}= e^{b_3} =$ `r round(exp(summary(mod.rate2)$coefficients[4]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[4,1]),2)`, `r round(exp(confint.default(mod.rate2)[4,2]),2)`)].

- The rate of doctor visits in **blacks** is `r round(100*(1-exp(summary(mod.rate2)$coefficients[5])),0)`% lower than in *non-blacks* (ref); adjusted $\hat{RR}= e^{b_4} =$ `r round(exp(summary(mod.rate2)$coefficients[5]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[5,1]),2)`, `r round(exp(confint.default(mod.rate2)[5,2]),2)`)].

- The rate of doctor visits in **Hispanics** is `r round(100*(1-exp(summary(mod.rate2)$coefficients[6])),0)`% lower than in *non-Hispanics* (ref); adjusted $\hat{RR}= e^{b_5} =$ `r round(exp(summary(mod.rate2)$coefficients[6]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[6,1]),2)`, `r round(exp(confint.default(mod.rate2)[6,2]),2)`)].

- The rate of doctor visits in the **Northeast** is `r round(100*(exp(summary(mod.rate2)$coefficients[7])-1),0)`% higher than in the *West* (ref); adjusted $\hat{RR}= e^{b_6} =$ `r round(exp(summary(mod.rate2)$coefficients[7]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[7,1]),2)`, `r round(exp(confint.default(mod.rate2)[7,2]),2)`)].

- The rate of doctor visits in the **Midwest** is `r round(100*(1-exp(summary(mod.rate2)$coefficients[8])),0)`% lower than in the *West* (ref); adjusted $\hat{RR}= e^{b_7} =$ `r round(exp(summary(mod.rate2)$coefficients[8]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[8,1]),2)`, `r round(exp(confint.default(mod.rate2)[8,2]),2)`)], (p-value `r ifelse(summary(mod.rate2)$coefficients[41]<.001,"<.001",paste("=",round(summary(mod.rate2)$coefficients[41],3)))`). 

- The rate of doctor visits in the **South** is `r round(100*(1-exp(summary(mod.rate2)$coefficients[9])),0)`% lower than in the *West* (ref); adjusted $\hat{RR}= e^{b_8} =$ `r round(exp(summary(mod.rate2)$coefficients[9]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[9,1]),2)`, `r round(exp(confint.default(mod.rate2)[9,2]),2)`)].

- The rate of doctor visits in the **insured** is `r round(100*(exp(summary(mod.rate2)$coefficients[10])-1),0)`% higher than in the *uninsured* (ref); adjusted $\hat{RR}= e^{b_9} =$ `r round(exp(summary(mod.rate2)$coefficients[10]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[10,1]),2)`, `r round(exp(confint.default(mod.rate2)[10,2]),2)`)].

- The rate of doctor visits in those with **1+ chronic condition** is `r round(100*(exp(summary(mod.rate2)$coefficients[11])-1),0)`% higher than in those with *no chronic conditions* (ref); adjusted $\hat{RR}= e^{b_{10}} =$ `r round(exp(summary(mod.rate2)$coefficients[11]),2)` [95% CI (`r round(exp(confint.default(mod.rate2)[11,1]),2)`, `r round(exp(confint.default(mod.rate2)[11,2]),2)`)].

The estimated or **predicted monthly rate of doctor visits** in an individual with covariate values `age = 50`, `educ = 12`, `female_factor = "Male"`, `black_factor = "Non-black"`, `hispanic_factor = "Hispanic"`, `location_factor = "Northeast"`, `insured_factor = "Insured"`, `chronic_factor = "No chronic conditions"` can be found using the `predict()` function:

```{r}
# Data frame that includes desired values of "x" for prediction
pred.x <- data.frame(age = 50, educ = 12, female_factor = "Male", black_factor = "Non-black", 
                     hispanic_factor = "Hispanic", location_factor = "Northeast", 
                     insured_factor = "Insured", chronic_factor = "No chronic conditions", 
                     followup = 1)

# Returns estimated mean
lambdahat <- predict(mod.rate2, newdata = pred.x, type = "response")
lambdahat
```

- According to our model, this individual is expected to visit the doctor `r round(lambdahat, 1)` times/month.


# Likelihood Ratio Test

Just as in logistic regression, a **Likelihood Ratio Test** can be used to simultaneously test the significance of a group or set of parameters when fitting a Poisson regression model of the count or of the rate. This test is commonly used to test the effect of categorical variables that are naturally made up of more than one dummy variable. For example, to test the significance of **geographic location** in the adjusted model, we would test: $H_0: \beta_6 = \beta_7 = \beta_8 = 0$ vs. $H_1: \beta_6$, $\beta_7$, $\beta_8$ not all 0.

Here, we are comparing two **nested models**,

  - **Full model**: $\log (\lambda) = \alpha + \beta_1$ Age $+ \beta_2$ Education $+ \beta_3$ Female $+ \beta_4$ Black $+ \beta_5$ Hispanic $+ \beta_6$ NE $+ \beta_7$ MW $+ \beta_8$ South $+ \beta_9$ Insured $+ \beta_{10}$ ChronicConditions 
  - **Reduced model** (i.e., model under $H_0$, without `location_factor`): $\log (\lambda) = \alpha + \beta_1$ Age $+ \beta_2$ Education $+ \beta_3$ Female $+ \beta_4$ Black $+ \beta_5$ Hispanic $+ \beta_6$ Insured $+ \beta_7$ ChronicConditions 

The **likelihood ratio test statistic** compares the likelihood of the full and reduced models, $\text{G} = -2 \log\text{-likelihood}(R) - (-2 \log\text{-likelihood}(F))$. The test statistic is compared to an Chi-square distribution with *degrees of freedom* equal to the number of parameters tested under $H_0$, $\chi^2_{df}$.

We can use the `Anova()` function in the `car` package to perform a likelihood ratio test for each variable included in the model without having to fit reduced models. The `Anova()` function applied to a model object (e.g., `mod.rate2`) returns individual likelihood ratio tests for each variable in the model. 

```{r}
# LRT using Anova() function in the "car" package
Anova(mod.rate2)
```

- Based on the output above, the **likelihood ratio test** of `location_factor` has a test statistic G = `r round(Anova(mod.rate2)$"LR Chisq"[6],1)`, which is compared to an Chi-square distribution with `r Anova(mod.rate2)$Df[6]` degrees of freedom. The overall effect of location is statistically significant in the presence of the other variables in this Poisson regression model (p-value `r ifelse(Anova(mod.rate2)$"Pr(>Chisq)"[6]<.001,"<.001",paste("=",round(Anova(mod.rate2)$"Pr(>Chisq)"[6],3)))`). We have evidence to reject $H_0$ and conclude that at least one $\beta_6$, $\beta_7$, or $\beta_8$ is not equal to 0. 


# Checking for Overdispersion

When using Poisson regression, an important assumption is that the count data arose from a **Poisson distribution**. One feature of the Poisson distribution is that the **mean** of the Poisson distributed random variable equals the **variance**. If there is evidence that the variance is not similar to the mean, then the Poisson distribution, and the Poisson regression model, may not be appropriate. At the beginning of this Lab, when we summarized the raw count data, we saw that the standard deviation of the count variable (`visits`) was much larger than the mean. So, the variance of the number of visits is also much larger than the mean number of visits:

```{r}
# Mean and SD of number of doctor visits in full sample
c(mn = mean(vis$visits, na.rm = TRUE), std = sd(vis$visits, na.rm = TRUE), 
  var = var(vis$visits, na.rm = TRUE))
```

When the variance is larger than the mean, this is known as **overdispersion**. A common cause of overdispersion is subject heterogeneity. Overdispersion can significantly affect model inference because the Poisson model will *underestimate* the standard errors of the model parameters, which will affect statistical inference (i.e., confidence intervals and p-values).

If overdispersion is an issue, then one solution is to use **negative binomial regression** instead of Poisson regression. A negative binomial distribution allows the variance of $Y$ to be larger than the mean of $Y$ since it assumes $Var(Y) = \mu + \dfrac{\mu^2}{k}$. The value $\dfrac{1}{k}$ is the **dispersion parameter** that is used to adjust the variance independently of the mean. Note that in Poisson regression, $\dfrac{1}{k} = 0$.

To assess if overdispersion is a problem in the data, we check to see if the ratio of the **Residual Deviance** to the **Residual Degrees of Freedom** is larger than 1. Notice that these values are printed below the estimated coefficients in the model `summary()` output. As a *rule of thumb*, a ratio $>$ 1.1 suggests overdispersion in the data. 

```{r}
# See row labeled "Residual deviance:" for residual deviance and its degrees of freedom
summary(mod.rate2)

# Checking overdispersion 
deviance(mod.rate2)/mod.rate2$df.residual
```

In our multiple Poisson regression model of the rate `mod.rate2`, the residual deviance is equal to `r format(round(deviance(mod.rate2),0), scientific=F)` and the residual degrees of freedom is equal to `r mod.rate2$df.residual`. Their ratio, `r round(deviance(mod.rate2)/mod.rate2$df.residual,3)` is much larger than 1, indicating that overdispersion is a problem in these data. 


# Negative Binomial Regression of the Count or Rate

The `glm.nb()` function in the `MASS` package can be used to fit a **negative binomial regression model**. Since this function only fits a negative binomial model, there is no `family=` argument in the `glm.nb()` function. Note that this model may be used to either fit a negative binomial model of the **count** or the **rate** and interpretation of the fitted parameters is the same as in Poisson regression. When modeling the rate, we must specify the offset term `offset(log(followup))`.

```{r}
# Negative binomial regression of the rate using glm.nb() function in the "MASS" package
mod.NBrate <- glm.nb(visits ~ age + educ + female_factor + black_factor + hispanic_factor + 
                     location_factor + insured_factor + chronic_factor + offset(log(followup)), 
                     data = vis)
summary(mod.NBrate)

# Comparing Poisson to Negative Binomial
round(cbind(bjPoi = coef(mod.rate2), sePoi = coef(summary(mod.rate2))[,2], 
            RRPoi = exp(coef(mod.rate2)), 
            bjNB = coef(mod.NBrate), seNB = coef(summary(mod.NBrate))[,2], 
            RRNB = exp(coef(mod.NBrate))), 3)
```

We see that the parameter estimates from the Poisson model (`bjPoi`) and the negative binomial model (`bjNB`) are very close. However, the standard errors of the parameters from the negative binomial model (`seNB`) are larger than in the Poisson model (`sePoi`). As a result, the individual Wald test p-values tend to be larger in the negative binomial model. The adjusted visit rate in the Northeast geographic location vs. West is now not significantly different in the negative binomial model (p-value `r ifelse(summary(mod.NBrate)$coefficients[40]<.001,"<.001",paste("=",round(summary(mod.NBrate)$coefficients[40],3)))`). The negative binomial model estimates the **overdispersion factor**, $1/k$ as `r round(mod.NBrate$theta,4)`. In a Poisson model, this parameter equals zero.

We can perform a **likelihood ratio test** to compare the full model (the negative binomial model) to the reduced model (the Poisson model) and test if the negative binomial model is providing a significantly better fit to the data. Under $H_0$, the negative binomial model does *not* provide a significantly better fit than the Poisson model. Under $H_1$, the negative binomial model *does* provide a significantly better fit than the Poisson model. The likelihood ratio test statistic $\text{G} = -2 \log\text{-likelihood}(Poisson) - (-2 \log\text{-likelihood}(NB))$ is compared to a chi-square distribution with 1 degree of freedom, $\chi^2_1$. Thus, the critical value of the G test statistic is equal to `r round(qchisq(.95, df=1), 2)` for a test performed at the $\alpha$ = 0.05-level.

```{r}
# LRT testing if NB model provides significantly better fit to data than Poisson
G <- as.numeric(-2*logLik(mod.rate2) - (-2*logLik(mod.NBrate)))
pval <- 1 - pchisq(G, df = 1)
pval
```

Here, the test statistic, $\text{G} =$ `r format(round(as.numeric(-2*logLik(mod.rate2)),2), scientific=F)` - `r format(round(as.numeric(-2*logLik(mod.NBrate)),2), scientific=F)` = `r format(round(G, 2), scientific=F)`, which is greater than the chi-square critical value `r round(qchisq(.95, df=1), 2)`. Thus, we have evidence to reject $H_0$ and conclude that overdispersion is present and the negative binomial model provides a significantly better fit than the Poisson model. The final adjusted rate ratios from the **negative binomial model of the rate** should be interpreted to address the research question in these data. 



